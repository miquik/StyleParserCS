//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.9.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from CSSParser.g4 by ANTLR 4.9.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;
using StyleParserCS.csskit.antlr4;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.9.2")]
// [System.CLSCompliant(false)]
public partial class CSSParser : Parser
{
    protected static DFA[] decisionToDFA;
    protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
    public const int
        STYLESHEET = 1, INLINESTYLE = 2, ATBLOCK = 3, CURLYBLOCK = 4, PARENBLOCK = 5, BRACKETBLOCK = 6,
        RULE = 7, SELECTOR = 8, ELEMENT = 9, PSEUDOCLASS = 10, PSEUDOELEM = 11, ADJACENT = 12,
        PRECEDING = 13, CHILD = 14, DESCENDANT = 15, ATTRIBUTE = 16, SET = 17, DECLARATION = 18,
        VALUE = 19, MEDIA_QUERY = 20, INVALID_STRING = 21, INVALID_SELECTOR = 22, INVALID_SELPART = 23,
        INVALID_DECLARATION = 24, INVALID_STATEMENT = 25, INVALID_ATSTATEMENT = 26,
        INVALID_IMPORT = 27, INVALID_DIRECTIVE = 28, IMPORTANT = 29, IDENT = 30, CHARSET = 31,
        IMPORT = 32, KEYFRAMES = 33, MEDIA = 34, PAGE = 35, MARGIN_AREA = 36, VIEWPORT = 37,
        FONTFACE = 38, ATKEYWORD = 39, CLASSKEYWORD = 40, STRING = 41, UNCLOSED_STRING = 42,
        HASH = 43, INDEX = 44, NUMBER = 45, PERCENTAGE = 46, DIMENSION = 47, URI = 48, UNCLOSED_URI = 49,
        UNIRANGE = 50, CDO = 51, CDC = 52, SEMICOLON = 53, COLON = 54, COMMA = 55, QUESTION = 56,
        PERCENT = 57, EQUALS = 58, SLASH = 59, GREATER = 60, LESS = 61, LCURLY = 62, RCURLY = 63,
        APOS = 64, QUOT = 65, LPAREN = 66, RPAREN = 67, LBRACKET = 68, RBRACKET = 69, EXCLAMATION = 70,
        TILDE = 71, MINUS = 72, PLUS = 73, ASTERISK = 74, POUND = 75, AMPERSAND = 76, HAT = 77,
        S = 78, COMMENT = 79, SL_COMMENT = 80, EXPRESSION = 81, FUNCTION = 82, INCLUDES = 83,
        DASHMATCH = 84, STARTSWITH = 85, ENDSWITH = 86, CONTAINS = 87, CTRL = 88, INVALID_TOKEN = 89,
        STRING_MACR = 90, UNCLOSED_STRING_MACR = 91, STRING_CHAR = 92;
    public const int
        RULE_inlinestyle = 0, RULE_stylesheet = 1, RULE_statement = 2, RULE_atstatement = 3,
        RULE_import_uri = 4, RULE_page = 5, RULE_margin_rule = 6, RULE_inlineset = 7,
        RULE_media = 8, RULE_media_query = 9, RULE_media_term = 10, RULE_media_expression = 11,
        RULE_media_rule = 12, RULE_keyframes_name = 13, RULE_keyframe_block = 14,
        RULE_keyframe_selector = 15, RULE_unknown_atrule = 16, RULE_unknown_atrule_body = 17,
        RULE_ruleset = 18, RULE_declarations = 19, RULE_declaration = 20, RULE_important = 21,
        RULE_property = 22, RULE_terms = 23, RULE_term = 24, RULE_funct = 25,
        RULE_valuepart = 26, RULE_funct_args = 27, RULE_funct_argument = 28, RULE_combined_selector = 29,
        RULE_combinator = 30, RULE_selector = 31, RULE_selpart = 32, RULE_attribute = 33,
        RULE_pseudo = 34, RULE_string = 35, RULE_bracketed_idents = 36, RULE_ident_list_item = 37,
        RULE_any = 38, RULE_nostatement = 39, RULE_noprop = 40, RULE_norule = 41,
        RULE_nomediaquery = 42;
    public static readonly string[] ruleNames = {
        "inlinestyle", "stylesheet", "statement", "atstatement", "import_uri",
        "page", "margin_rule", "inlineset", "media", "media_query", "media_term",
        "media_expression", "media_rule", "keyframes_name", "keyframe_block",
        "keyframe_selector", "unknown_atrule", "unknown_atrule_body", "ruleset",
        "declarations", "declaration", "important", "property", "terms", "term",
        "funct", "valuepart", "funct_args", "funct_argument", "combined_selector",
        "combinator", "selector", "selpart", "attribute", "pseudo", "string",
        "bracketed_idents", "ident_list_item", "any", "nostatement", "noprop",
        "norule", "nomediaquery"
    };

    private static readonly string[] _LiteralNames = {
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, "'important'", null, null, "'@import'",
        "'@keyframes'", "'@media'", "'@page'", null, "'@viewport'", "'@font-face'",
        null, null, null, null, null, null, null, null, null, null, null, null,
        "'<!--'", "'-->'", "';'", "':'", "','", "'?'", "'%'", "'='", "'/'", "'>'",
        "'<'", "'{'", "'}'", "'''", "'\"'", "'('", "')'", "'['", "']'", "'!'",
        "'~'", "'-'", "'+'", "'*'", "'#'", "'&'", "'^'", null, null, null, "'expression('",
        null, "'~='", "'|='", "'^='", "'$='", "'*='"
    };
    private static readonly string[] _SymbolicNames = {
        null, "STYLESHEET", "INLINESTYLE", "ATBLOCK", "CURLYBLOCK", "PARENBLOCK",
        "BRACKETBLOCK", "RULE", "SELECTOR", "ELEMENT", "PSEUDOCLASS", "PSEUDOELEM",
        "ADJACENT", "PRECEDING", "CHILD", "DESCENDANT", "ATTRIBUTE", "SET", "DECLARATION",
        "VALUE", "MEDIA_QUERY", "INVALID_STRING", "INVALID_SELECTOR", "INVALID_SELPART",
        "INVALID_DECLARATION", "INVALID_STATEMENT", "INVALID_ATSTATEMENT", "INVALID_IMPORT",
        "INVALID_DIRECTIVE", "IMPORTANT", "IDENT", "CHARSET", "IMPORT", "KEYFRAMES",
        "MEDIA", "PAGE", "MARGIN_AREA", "VIEWPORT", "FONTFACE", "ATKEYWORD", "CLASSKEYWORD",
        "STRING", "UNCLOSED_STRING", "HASH", "INDEX", "NUMBER", "PERCENTAGE",
        "DIMENSION", "URI", "UNCLOSED_URI", "UNIRANGE", "CDO", "CDC", "SEMICOLON",
        "COLON", "COMMA", "QUESTION", "PERCENT", "EQUALS", "SLASH", "GREATER",
        "LESS", "LCURLY", "RCURLY", "APOS", "QUOT", "LPAREN", "RPAREN", "LBRACKET",
        "RBRACKET", "EXCLAMATION", "TILDE", "MINUS", "PLUS", "ASTERISK", "POUND",
        "AMPERSAND", "HAT", "S", "COMMENT", "SL_COMMENT", "EXPRESSION", "FUNCTION",
        "INCLUDES", "DASHMATCH", "STARTSWITH", "ENDSWITH", "CONTAINS", "CTRL",
        "INVALID_TOKEN", "STRING_MACR", "UNCLOSED_STRING_MACR", "STRING_CHAR"
    };
    public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

    [NotNull]
    public override IVocabulary Vocabulary
    {
        get
        {
            return DefaultVocabulary;
        }
    }

    public override string GrammarFileName { get { return "CSSParser.g4"; } }

    public override string[] RuleNames { get { return ruleNames; } }

    public override string SerializedAtn { get { return new string(_serializedATN); } }

    static CSSParser()
    {
        decisionToDFA = new DFA[_ATN.NumberOfDecisions];
        for (int i = 0; i < _ATN.NumberOfDecisions; i++)
        {
            decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
        }
    }


    // logger
    // function level e.g. function(function(function()))
    private int functLevel = 0;

    /**
     * Obtains the current
     
      lexer state from current token
     */
    private CSSLexerState getCurrentLexerState(IToken t)
    {
        if (t is CSSToken){
            return ((CSSToken)t).LexerState;
        }
        return null;
    }

    /**
      * get overtyped error strategy
      * - strategy must be set to CSSErrorStrategy before parsing !!
      */
    private CSSErrorStrategy getCSSErrorHandler()
    {
        if (this.ErrorHandler is CSSErrorStrategy){
            return ((CSSErrorStrategy)this.ErrorHandler);
        }
        // log.error("ERROR STRATEGY IS NOT OF TYPE CSSErrorStrategy");
        return null;
    }


    public CSSParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

    public CSSParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
    : base(input, output, errorOutput)
    {
        Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
    }

    public partial class InlinestyleContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationsContext declarations()
        {
            return GetRuleContext<DeclarationsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public InlinesetContext[] inlineset()
        {
            return GetRuleContexts<InlinesetContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public InlinesetContext inlineset(int i)
        {
            return GetRuleContext<InlinesetContext>(i);
        }
        public InlinestyleContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_inlinestyle; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterInlinestyle(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitInlinestyle(this);
        }
    }

    [RuleVersion(0)]
    public InlinestyleContext inlinestyle()
    {
        InlinestyleContext _localctx = new InlinestyleContext(Context, State);
        EnterRule(_localctx, 0, RULE_inlinestyle);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 89;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 86;
                            Match(S);
                        }
                    }
                    State = 91;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 98;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 2, Context))
                {
                    case 1:
                        {
                            State = 92;
                            declarations();
                        }
                        break;
                    case 2:
                        {
                            State = 94;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            do
                            {
                                {
                                    {
                                        State = 93;
                                        inlineset();
                                    }
                                }
                                State = 96;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            } while (_la == COLON || _la == LCURLY);
                        }
                        break;
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | inlinestyle | should be EMPTY");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class StylesheetContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] CDO() { return GetTokens(CSSParser.CDO); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode CDO(int i)
        {
            return GetToken(CSSParser.CDO, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] CDC() { return GetTokens(CSSParser.CDC); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode CDC(int i)
        {
            return GetToken(CSSParser.CDC, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public NostatementContext[] nostatement()
        {
            return GetRuleContexts<NostatementContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public NostatementContext nostatement(int i)
        {
            return GetRuleContext<NostatementContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public StatementContext[] statement()
        {
            return GetRuleContexts<StatementContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public StatementContext statement(int i)
        {
            return GetRuleContext<StatementContext>(i);
        }
        public StylesheetContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_stylesheet; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterStylesheet(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitStylesheet(this);
        }
    }

    [RuleVersion(0)]
    public StylesheetContext stylesheet()
    {
        StylesheetContext _localctx = new StylesheetContext(Context, State);
        EnterRule(_localctx, 2, RULE_stylesheet);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 107;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INVALID_STRING) | (1L << INVALID_SELPART) | (1L << IDENT) | (1L << CHARSET) | (1L << IMPORT) | (1L << KEYFRAMES) | (1L << MEDIA) | (1L << PAGE) | (1L << VIEWPORT) | (1L << FONTFACE) | (1L << ATKEYWORD) | (1L << CLASSKEYWORD) | (1L << STRING) | (1L << UNCLOSED_STRING) | (1L << HASH) | (1L << NUMBER) | (1L << PERCENTAGE) | (1L << DIMENSION) | (1L << URI) | (1L << UNCLOSED_URI) | (1L << UNIRANGE) | (1L << CDO) | (1L << CDC) | (1L << SEMICOLON) | (1L << COLON) | (1L << COMMA) | (1L << QUESTION) | (1L << PERCENT) | (1L << EQUALS) | (1L << SLASH) | (1L << GREATER) | (1L << LESS) | (1L << LCURLY) | (1L << RCURLY))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (APOS - 64)) | (1L << (QUOT - 64)) | (1L << (RPAREN - 64)) | (1L << (LBRACKET - 64)) | (1L << (EXCLAMATION - 64)) | (1L << (MINUS - 64)) | (1L << (PLUS - 64)) | (1L << (ASTERISK - 64)) | (1L << (POUND - 64)) | (1L << (AMPERSAND - 64)) | (1L << (HAT - 64)) | (1L << (S - 64)) | (1L << (INCLUDES - 64)) | (1L << (DASHMATCH - 64)) | (1L << (CTRL - 64)) | (1L << (INVALID_TOKEN - 64)))) != 0))
                {
                    {
                        State = 105;
                        ErrorHandler.Sync(this);
                        switch (TokenStream.LA(1))
                        {
                            case CDO:
                                {
                                    State = 100;
                                    Match(CDO);
                                }
                                break;
                            case CDC:
                                {
                                    State = 101;
                                    Match(CDC);
                                }
                                break;
                            case S:
                                {
                                    State = 102;
                                    Match(S);
                                }
                                break;
                            case SEMICOLON:
                            case RCURLY:
                            case APOS:
                            case QUOT:
                                {
                                    State = 103;
                                    nostatement();
                                }
                                break;
                            case INVALID_STRING:
                            case INVALID_SELPART:
                            case IDENT:
                            case CHARSET:
                            case IMPORT:
                            case KEYFRAMES:
                            case MEDIA:
                            case PAGE:
                            case VIEWPORT:
                            case FONTFACE:
                            case ATKEYWORD:
                            case CLASSKEYWORD:
                            case STRING:
                            case UNCLOSED_STRING:
                            case HASH:
                            case NUMBER:
                            case PERCENTAGE:
                            case DIMENSION:
                            case URI:
                            case UNCLOSED_URI:
                            case UNIRANGE:
                            case COLON:
                            case COMMA:
                            case QUESTION:
                            case PERCENT:
                            case EQUALS:
                            case SLASH:
                            case GREATER:
                            case LESS:
                            case LCURLY:
                            case RPAREN:
                            case LBRACKET:
                            case EXCLAMATION:
                            case MINUS:
                            case PLUS:
                            case ASTERISK:
                            case POUND:
                            case AMPERSAND:
                            case HAT:
                            case INCLUDES:
                            case DASHMATCH:
                            case CTRL:
                            case INVALID_TOKEN:
                                {
                                    State = 104;
                                    statement();
                                }
                                break;
                            default:
                                throw new NoViableAltException(this);
                        }
                    }
                    State = 109;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | stylesheet | should be EMPTY");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class StatementContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public RulesetContext ruleset()
        {
            return GetRuleContext<RulesetContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AtstatementContext atstatement()
        {
            return GetRuleContext<AtstatementContext>(0);
        }
        public StatementContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_statement; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterStatement(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitStatement(this);
        }
    }

    [RuleVersion(0)]
    public StatementContext statement()
    {
        StatementContext _localctx = new StatementContext(Context, State);
        EnterRule(_localctx, 4, RULE_statement);
        try
        {
            State = 112;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case INVALID_STRING:
                case INVALID_SELPART:
                case IDENT:
                case CLASSKEYWORD:
                case STRING:
                case UNCLOSED_STRING:
                case HASH:
                case NUMBER:
                case PERCENTAGE:
                case DIMENSION:
                case URI:
                case UNCLOSED_URI:
                case UNIRANGE:
                case COLON:
                case COMMA:
                case QUESTION:
                case PERCENT:
                case EQUALS:
                case SLASH:
                case GREATER:
                case LESS:
                case LCURLY:
                case RPAREN:
                case LBRACKET:
                case EXCLAMATION:
                case MINUS:
                case PLUS:
                case ASTERISK:
                case POUND:
                case AMPERSAND:
                case HAT:
                case INCLUDES:
                case DASHMATCH:
                case CTRL:
                case INVALID_TOKEN:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 110;
                        ruleset();
                    }
                    break;
                case CHARSET:
                case IMPORT:
                case KEYFRAMES:
                case MEDIA:
                case PAGE:
                case VIEWPORT:
                case FONTFACE:
                case ATKEYWORD:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 111;
                        atstatement();
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | statement | should be EMPTY");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class AtstatementContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHARSET() { return GetToken(CSSParser.CHARSET, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPORT() { return GetToken(CSSParser.IMPORT, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public Import_uriContext import_uri()
        {
            return GetRuleContext<Import_uriContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(CSSParser.SEMICOLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public MediaContext media()
        {
            return GetRuleContext<MediaContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public PageContext page()
        {
            return GetRuleContext<PageContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VIEWPORT() { return GetToken(CSSParser.VIEWPORT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CSSParser.LCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationsContext declarations()
        {
            return GetRuleContext<DeclarationsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FONTFACE() { return GetToken(CSSParser.FONTFACE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MEDIA() { return GetToken(CSSParser.MEDIA, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public Media_ruleContext[] media_rule()
        {
            return GetRuleContexts<Media_ruleContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Media_ruleContext media_rule(int i)
        {
            return GetRuleContext<Media_ruleContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEYFRAMES() { return GetToken(CSSParser.KEYFRAMES, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public Keyframes_nameContext keyframes_name()
        {
            return GetRuleContext<Keyframes_nameContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Keyframe_blockContext[] keyframe_block()
        {
            return GetRuleContexts<Keyframe_blockContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Keyframe_blockContext keyframe_block(int i)
        {
            return GetRuleContext<Keyframe_blockContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Unknown_atruleContext unknown_atrule()
        {
            return GetRuleContext<Unknown_atruleContext>(0);
        }
        public AtstatementContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_atstatement; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterAtstatement(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitAtstatement(this);
        }
    }

    [RuleVersion(0)]
    public AtstatementContext atstatement()
    {
        AtstatementContext _localctx = new AtstatementContext(Context, State);
        EnterRule(_localctx, 6, RULE_atstatement);
        int _la;
        try
        {
            State = 235;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case CHARSET:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 114;
                        Match(CHARSET);
                    }
                    break;
                case IMPORT:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 115;
                        Match(IMPORT);
                        State = 119;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 116;
                                    Match(S);
                                }
                            }
                            State = 121;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 122;
                        import_uri();
                        State = 126;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 123;
                                    Match(S);
                                }
                            }
                            State = 128;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 130;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INVALID_STRING) | (1L << IDENT) | (1L << STRING) | (1L << UNCLOSED_STRING) | (1L << NUMBER) | (1L << PERCENTAGE) | (1L << DIMENSION) | (1L << URI) | (1L << UNCLOSED_URI) | (1L << UNIRANGE) | (1L << COLON) | (1L << QUESTION) | (1L << PERCENT) | (1L << EQUALS) | (1L << SLASH) | (1L << GREATER) | (1L << LESS))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (LPAREN - 66)) | (1L << (RPAREN - 66)) | (1L << (EXCLAMATION - 66)) | (1L << (MINUS - 66)) | (1L << (PLUS - 66)) | (1L << (ASTERISK - 66)) | (1L << (POUND - 66)) | (1L << (AMPERSAND - 66)) | (1L << (HAT - 66)) | (1L << (FUNCTION - 66)) | (1L << (INCLUDES - 66)) | (1L << (DASHMATCH - 66)) | (1L << (CTRL - 66)))) != 0))
                        {
                            {
                                State = 129;
                                media();
                            }
                        }

                        State = 132;
                        Match(SEMICOLON);
                    }
                    break;
                case PAGE:
                    EnterOuterAlt(_localctx, 3);
                    {
                        State = 134;
                        page();
                    }
                    break;
                case VIEWPORT:
                    EnterOuterAlt(_localctx, 4);
                    {
                        State = 135;
                        Match(VIEWPORT);
                        State = 139;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 136;
                                    Match(S);
                                }
                            }
                            State = 141;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 142;
                        Match(LCURLY);
                        State = 146;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 143;
                                    Match(S);
                                }
                            }
                            State = 148;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 149;
                        declarations();
                        State = 150;
                        Match(RCURLY);
                    }
                    break;
                case FONTFACE:
                    EnterOuterAlt(_localctx, 5);
                    {
                        State = 152;
                        Match(FONTFACE);
                        State = 156;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 153;
                                    Match(S);
                                }
                            }
                            State = 158;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 159;
                        Match(LCURLY);
                        State = 163;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 160;
                                    Match(S);
                                }
                            }
                            State = 165;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 166;
                        declarations();
                        State = 167;
                        Match(RCURLY);
                    }
                    break;
                case MEDIA:
                    EnterOuterAlt(_localctx, 6);
                    {
                        State = 169;
                        Match(MEDIA);
                        State = 173;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 170;
                                    Match(S);
                                }
                            }
                            State = 175;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 177;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INVALID_STRING) | (1L << IDENT) | (1L << STRING) | (1L << UNCLOSED_STRING) | (1L << NUMBER) | (1L << PERCENTAGE) | (1L << DIMENSION) | (1L << URI) | (1L << UNCLOSED_URI) | (1L << UNIRANGE) | (1L << COLON) | (1L << QUESTION) | (1L << PERCENT) | (1L << EQUALS) | (1L << SLASH) | (1L << GREATER) | (1L << LESS))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (LPAREN - 66)) | (1L << (RPAREN - 66)) | (1L << (EXCLAMATION - 66)) | (1L << (MINUS - 66)) | (1L << (PLUS - 66)) | (1L << (ASTERISK - 66)) | (1L << (POUND - 66)) | (1L << (AMPERSAND - 66)) | (1L << (HAT - 66)) | (1L << (FUNCTION - 66)) | (1L << (INCLUDES - 66)) | (1L << (DASHMATCH - 66)) | (1L << (CTRL - 66)))) != 0))
                        {
                            {
                                State = 176;
                                media();
                            }
                        }

                        State = 179;
                        Match(LCURLY);
                        State = 183;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 180;
                                    Match(S);
                                }
                            }
                            State = 185;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 195;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INVALID_STRING) | (1L << INVALID_SELPART) | (1L << IDENT) | (1L << CHARSET) | (1L << IMPORT) | (1L << KEYFRAMES) | (1L << MEDIA) | (1L << PAGE) | (1L << VIEWPORT) | (1L << FONTFACE) | (1L << ATKEYWORD) | (1L << CLASSKEYWORD) | (1L << STRING) | (1L << UNCLOSED_STRING) | (1L << HASH) | (1L << NUMBER) | (1L << PERCENTAGE) | (1L << DIMENSION) | (1L << URI) | (1L << UNCLOSED_URI) | (1L << UNIRANGE) | (1L << COLON) | (1L << COMMA) | (1L << QUESTION) | (1L << PERCENT) | (1L << EQUALS) | (1L << SLASH) | (1L << GREATER) | (1L << LESS) | (1L << LCURLY))) != 0) || ((((_la - 67)) & ~0x3f) == 0 && ((1L << (_la - 67)) & ((1L << (RPAREN - 67)) | (1L << (LBRACKET - 67)) | (1L << (EXCLAMATION - 67)) | (1L << (MINUS - 67)) | (1L << (PLUS - 67)) | (1L << (ASTERISK - 67)) | (1L << (POUND - 67)) | (1L << (AMPERSAND - 67)) | (1L << (HAT - 67)) | (1L << (INCLUDES - 67)) | (1L << (DASHMATCH - 67)) | (1L << (CTRL - 67)) | (1L << (INVALID_TOKEN - 67)))) != 0))
                        {
                            {
                                {
                                    State = 186;
                                    media_rule();
                                    State = 190;
                                    ErrorHandler.Sync(this);
                                    _la = TokenStream.LA(1);
                                    while (_la == S)
                                    {
                                        {
                                            {
                                                State = 187;
                                                Match(S);
                                            }
                                        }
                                        State = 192;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.LA(1);
                                    }
                                }
                            }
                            State = 197;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 198;
                        Match(RCURLY);
                    }
                    break;
                case KEYFRAMES:
                    EnterOuterAlt(_localctx, 7);
                    {
                        State = 199;
                        Match(KEYFRAMES);
                        State = 203;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 200;
                                    Match(S);
                                }
                            }
                            State = 205;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 206;
                        keyframes_name();
                        State = 210;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 207;
                                    Match(S);
                                }
                            }
                            State = 212;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 213;
                        Match(LCURLY);
                        State = 217;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 214;
                                    Match(S);
                                }
                            }
                            State = 219;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 229;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == IDENT || _la == PERCENTAGE)
                        {
                            {
                                {
                                    State = 220;
                                    keyframe_block();
                                    State = 224;
                                    ErrorHandler.Sync(this);
                                    _la = TokenStream.LA(1);
                                    while (_la == S)
                                    {
                                        {
                                            {
                                                State = 221;
                                                Match(S);
                                            }
                                        }
                                        State = 226;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.LA(1);
                                    }
                                }
                            }
                            State = 231;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 232;
                        Match(RCURLY);
                    }
                    break;
                case ATKEYWORD:
                    EnterOuterAlt(_localctx, 8);
                    {
                        State = 234;
                        unknown_atrule();
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | atstatement consume until RCURLY | SEMICOLON");
            IntervalSet intervalSet = new IntervalSet(RCURLY, SEMICOLON);
            getCSSErrorHandler().consumeUntilGreedy(this, intervalSet);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_ATSTATEMENT, "INVALID_ATSTATEMENT"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Import_uriContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(CSSParser.STRING, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URI() { return GetToken(CSSParser.URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCLOSED_STRING() { return GetToken(CSSParser.UNCLOSED_STRING, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCLOSED_URI() { return GetToken(CSSParser.UNCLOSED_URI, 0); }
        public Import_uriContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_import_uri; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterImport_uri(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitImport_uri(this);
        }
    }

    [RuleVersion(0)]
    public Import_uriContext import_uri()
    {
        Import_uriContext _localctx = new Import_uriContext(Context, State);
        EnterRule(_localctx, 8, RULE_import_uri);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 237;
                _la = TokenStream.LA(1);
                if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << STRING) | (1L << UNCLOSED_STRING) | (1L << URI) | (1L << UNCLOSED_URI))) != 0)))
                {
                    ErrorHandler.RecoverInline(this);
                }
                else
                {
                    ErrorHandler.ReportMatch(this);
                    Consume();
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | import_uri | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class PageContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PAGE() { return GetToken(CSSParser.PAGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CSSParser.LCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationsContext declarations()
        {
            return GetRuleContext<DeclarationsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public PseudoContext pseudo()
        {
            return GetRuleContext<PseudoContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Margin_ruleContext[] margin_rule()
        {
            return GetRuleContexts<Margin_ruleContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Margin_ruleContext margin_rule(int i)
        {
            return GetRuleContext<Margin_ruleContext>(i);
        }
        public PageContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_page; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterPage(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitPage(this);
        }
    }

    [RuleVersion(0)]
    public PageContext page()
    {
        PageContext _localctx = new PageContext(Context, State);
        EnterRule(_localctx, 10, RULE_page);
        int _la;
        try
        {
            int _alt;
            EnterOuterAlt(_localctx, 1);
            {
                State = 239;
                Match(PAGE);
                State = 243;
                ErrorHandler.Sync(this);
                _alt = Interpreter.AdaptivePredict(TokenStream, 24, Context);
                while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                {
                    if (_alt == 1)
                    {
                        {
                            {
                                State = 240;
                                Match(S);
                            }
                        }
                    }
                    State = 245;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 24, Context);
                }
                State = 247;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                if (_la == IDENT)
                {
                    {
                        State = 246;
                        Match(IDENT);
                    }
                }

                State = 250;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                if (_la == COLON)
                {
                    {
                        State = 249;
                        pseudo();
                    }
                }

                State = 255;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 252;
                            Match(S);
                        }
                    }
                    State = 257;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 258;
                Match(LCURLY);
                State = 262;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 259;
                            Match(S);
                        }
                    }
                    State = 264;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 265;
                declarations();
                State = 269;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == MARGIN_AREA)
                {
                    {
                        {
                            State = 266;
                            margin_rule();
                        }
                    }
                    State = 271;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 272;
                Match(RCURLY);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | page | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Margin_ruleContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MARGIN_AREA() { return GetToken(CSSParser.MARGIN_AREA, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CSSParser.LCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationsContext declarations()
        {
            return GetRuleContext<DeclarationsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public Margin_ruleContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_margin_rule; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterMargin_rule(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitMargin_rule(this);
        }
    }

    [RuleVersion(0)]
    public Margin_ruleContext margin_rule()
    {
        Margin_ruleContext _localctx = new Margin_ruleContext(Context, State);
        EnterRule(_localctx, 12, RULE_margin_rule);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 274;
                Match(MARGIN_AREA);
                State = 278;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 275;
                            Match(S);
                        }
                    }
                    State = 280;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 281;
                Match(LCURLY);
                State = 285;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 282;
                            Match(S);
                        }
                    }
                    State = 287;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 288;
                declarations();
                State = 289;
                Match(RCURLY);
                State = 293;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 290;
                            Match(S);
                        }
                    }
                    State = 295;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | margin_rule | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class InlinesetContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CSSParser.LCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationsContext declarations()
        {
            return GetRuleContext<DeclarationsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public PseudoContext[] pseudo()
        {
            return GetRuleContexts<PseudoContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public PseudoContext pseudo(int i)
        {
            return GetRuleContext<PseudoContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CSSParser.COMMA); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode COMMA(int i)
        {
            return GetToken(CSSParser.COMMA, i);
        }
        public InlinesetContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_inlineset; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterInlineset(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitInlineset(this);
        }
    }

    [RuleVersion(0)]
    public InlinesetContext inlineset()
    {
        InlinesetContext _localctx = new InlinesetContext(Context, State);
        EnterRule(_localctx, 14, RULE_inlineset);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 322;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                if (_la == COLON)
                {
                    {
                        State = 296;
                        pseudo();
                        State = 300;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 297;
                                    Match(S);
                                }
                            }
                            State = 302;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 319;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == COMMA)
                        {
                            {
                                {
                                    State = 303;
                                    Match(COMMA);
                                    State = 307;
                                    ErrorHandler.Sync(this);
                                    _la = TokenStream.LA(1);
                                    while (_la == S)
                                    {
                                        {
                                            {
                                                State = 304;
                                                Match(S);
                                            }
                                        }
                                        State = 309;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.LA(1);
                                    }
                                    State = 310;
                                    pseudo();
                                    State = 314;
                                    ErrorHandler.Sync(this);
                                    _la = TokenStream.LA(1);
                                    while (_la == S)
                                    {
                                        {
                                            {
                                                State = 311;
                                                Match(S);
                                            }
                                        }
                                        State = 316;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.LA(1);
                                    }
                                }
                            }
                            State = 321;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                }

                State = 324;
                Match(LCURLY);
                State = 325;
                declarations();
                State = 326;
                Match(RCURLY);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | inlineset | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class MediaContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public Media_queryContext[] media_query()
        {
            return GetRuleContexts<Media_queryContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Media_queryContext media_query(int i)
        {
            return GetRuleContext<Media_queryContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CSSParser.COMMA); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode COMMA(int i)
        {
            return GetToken(CSSParser.COMMA, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public MediaContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_media; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterMedia(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitMedia(this);
        }
    }

    [RuleVersion(0)]
    public MediaContext media()
    {
        MediaContext _localctx = new MediaContext(Context, State);
        EnterRule(_localctx, 16, RULE_media);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 328;
                media_query();
                State = 339;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == COMMA)
                {
                    {
                        {
                            State = 329;
                            Match(COMMA);
                            State = 333;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (_la == S)
                            {
                                {
                                    {
                                        State = 330;
                                        Match(S);
                                    }
                                }
                                State = 335;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 336;
                            media_query();
                        }
                    }
                    State = 341;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING MEDIA ERROR | consume until COMMA, LCURLY, SEMICOLON");
            IntervalSet intervalSet = new IntervalSet(COMMA, LCURLY, SEMICOLON);
            getCSSErrorHandler().consumeUntil(this, intervalSet, CSSLexerState.RecoveryMode.BALANCED, null);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Media_queryContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public Media_termContext[] media_term()
        {
            return GetRuleContexts<Media_termContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Media_termContext media_term(int i)
        {
            return GetRuleContext<Media_termContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public Media_queryContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_media_query; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterMedia_query(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitMedia_query(this);
        }
    }

    [RuleVersion(0)]
    public Media_queryContext media_query()
    {
        Media_queryContext _localctx = new Media_queryContext(Context, State);
        EnterRule(_localctx, 18, RULE_media_query);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 349;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                do
                {
                    {
                        {
                            State = 342;
                            media_term();
                            State = 346;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (_la == S)
                            {
                                {
                                    {
                                        State = 343;
                                        Match(S);
                                    }
                                }
                                State = 348;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                        }
                    }
                    State = 351;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                } while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INVALID_STRING) | (1L << IDENT) | (1L << STRING) | (1L << UNCLOSED_STRING) | (1L << NUMBER) | (1L << PERCENTAGE) | (1L << DIMENSION) | (1L << URI) | (1L << UNCLOSED_URI) | (1L << UNIRANGE) | (1L << COLON) | (1L << QUESTION) | (1L << PERCENT) | (1L << EQUALS) | (1L << SLASH) | (1L << GREATER) | (1L << LESS))) != 0) || ((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (LPAREN - 66)) | (1L << (RPAREN - 66)) | (1L << (EXCLAMATION - 66)) | (1L << (MINUS - 66)) | (1L << (PLUS - 66)) | (1L << (ASTERISK - 66)) | (1L << (POUND - 66)) | (1L << (AMPERSAND - 66)) | (1L << (HAT - 66)) | (1L << (FUNCTION - 66)) | (1L << (INCLUDES - 66)) | (1L << (DASHMATCH - 66)) | (1L << (CTRL - 66)))) != 0));
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | media_query | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Media_termContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public Media_expressionContext media_expression()
        {
            return GetRuleContext<Media_expressionContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public NomediaqueryContext nomediaquery()
        {
            return GetRuleContext<NomediaqueryContext>(0);
        }
        public Media_termContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_media_term; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterMedia_term(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitMedia_term(this);
        }
    }

    [RuleVersion(0)]
    public Media_termContext media_term()
    {
        Media_termContext _localctx = new Media_termContext(Context, State);
        EnterRule(_localctx, 20, RULE_media_term);
        try
        {
            State = 358;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case IDENT:
                case LPAREN:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 355;
                        ErrorHandler.Sync(this);
                        switch (TokenStream.LA(1))
                        {
                            case IDENT:
                                {
                                    State = 353;
                                    Match(IDENT);
                                }
                                break;
                            case LPAREN:
                                {
                                    State = 354;
                                    media_expression();
                                }
                                break;
                            default:
                                throw new NoViableAltException(this);
                        }
                    }
                    break;
                case INVALID_STRING:
                case STRING:
                case UNCLOSED_STRING:
                case NUMBER:
                case PERCENTAGE:
                case DIMENSION:
                case URI:
                case UNCLOSED_URI:
                case UNIRANGE:
                case COLON:
                case QUESTION:
                case PERCENT:
                case EQUALS:
                case SLASH:
                case GREATER:
                case LESS:
                case RPAREN:
                case EXCLAMATION:
                case MINUS:
                case PLUS:
                case ASTERISK:
                case POUND:
                case AMPERSAND:
                case HAT:
                case FUNCTION:
                case INCLUDES:
                case DASHMATCH:
                case CTRL:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 357;
                        nomediaquery();
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING MEDIATERM ERROR | consume until COMMA, LCURLY, SEMICOLON");
            IntervalSet intervalSet = new IntervalSet(COMMA, LCURLY, SEMICOLON);
            getCSSErrorHandler().consumeUntil(this, intervalSet, CSSLexerState.RecoveryMode.RULE, null);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Media_expressionContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CSSParser.LPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public TermsContext terms()
        {
            return GetRuleContext<TermsContext>(0);
        }
        public Media_expressionContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_media_expression; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterMedia_expression(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitMedia_expression(this);
        }
    }

    [RuleVersion(0)]
    public Media_expressionContext media_expression()
    {
        Media_expressionContext _localctx = new Media_expressionContext(Context, State);
        EnterRule(_localctx, 22, RULE_media_expression);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 360;
                Match(LPAREN);
                State = 364;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 361;
                            Match(S);
                        }
                    }
                    State = 366;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 367;
                Match(IDENT);
                State = 371;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 368;
                            Match(S);
                        }
                    }
                    State = 373;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 382;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                if (_la == COLON)
                {
                    {
                        State = 374;
                        Match(COLON);
                        State = 378;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 375;
                                    Match(S);
                                }
                            }
                            State = 380;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 381;
                        terms();
                    }
                }

                State = 384;
                Match(RPAREN);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING media_expression ERROR | consume until RPAREN, SEMICOLON");
            IntervalSet intervalSet = new IntervalSet(RPAREN, SEMICOLON);
            getCSSErrorHandler().consumeUntilGreedy(this, intervalSet);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Media_ruleContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public RulesetContext ruleset()
        {
            return GetRuleContext<RulesetContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AtstatementContext atstatement()
        {
            return GetRuleContext<AtstatementContext>(0);
        }
        public Media_ruleContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_media_rule; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterMedia_rule(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitMedia_rule(this);
        }
    }

    [RuleVersion(0)]
    public Media_ruleContext media_rule()
    {
        Media_ruleContext _localctx = new Media_ruleContext(Context, State);
        EnterRule(_localctx, 24, RULE_media_rule);
        try
        {
            State = 388;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case INVALID_STRING:
                case INVALID_SELPART:
                case IDENT:
                case CLASSKEYWORD:
                case STRING:
                case UNCLOSED_STRING:
                case HASH:
                case NUMBER:
                case PERCENTAGE:
                case DIMENSION:
                case URI:
                case UNCLOSED_URI:
                case UNIRANGE:
                case COLON:
                case COMMA:
                case QUESTION:
                case PERCENT:
                case EQUALS:
                case SLASH:
                case GREATER:
                case LESS:
                case LCURLY:
                case RPAREN:
                case LBRACKET:
                case EXCLAMATION:
                case MINUS:
                case PLUS:
                case ASTERISK:
                case POUND:
                case AMPERSAND:
                case HAT:
                case INCLUDES:
                case DASHMATCH:
                case CTRL:
                case INVALID_TOKEN:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 386;
                        ruleset();
                    }
                    break;
                case CHARSET:
                case IMPORT:
                case KEYFRAMES:
                case MEDIA:
                case PAGE:
                case VIEWPORT:
                case FONTFACE:
                case ATKEYWORD:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 387;
                        atstatement();
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | media_rule | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Keyframes_nameContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public StringContext stringv()
        {
            return GetRuleContext<StringContext>(0);
        }
        public Keyframes_nameContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_keyframes_name; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterKeyframes_name(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitKeyframes_name(this);
        }
    }

    [RuleVersion(0)]
    public Keyframes_nameContext keyframes_name()
    {
        Keyframes_nameContext _localctx = new Keyframes_nameContext(Context, State);
        EnterRule(_localctx, 26, RULE_keyframes_name);
        try
        {
            State = 392;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case IDENT:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 390;
                        Match(IDENT);
                    }
                    break;
                case INVALID_STRING:
                case STRING:
                case UNCLOSED_STRING:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 391;
                        stringv();
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {
            _localctx.exception = re;
            ErrorHandler.ReportError(this, re);
            ErrorHandler.Recover(this, re);
        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Keyframe_blockContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public Keyframe_selectorContext[] keyframe_selector()
        {
            return GetRuleContexts<Keyframe_selectorContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Keyframe_selectorContext keyframe_selector(int i)
        {
            return GetRuleContext<Keyframe_selectorContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CSSParser.LCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationsContext declarations()
        {
            return GetRuleContext<DeclarationsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CSSParser.COMMA); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode COMMA(int i)
        {
            return GetToken(CSSParser.COMMA, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public Keyframe_blockContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_keyframe_block; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterKeyframe_block(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitKeyframe_block(this);
        }
    }

    [RuleVersion(0)]
    public Keyframe_blockContext keyframe_block()
    {
        Keyframe_blockContext _localctx = new Keyframe_blockContext(Context, State);
        EnterRule(_localctx, 28, RULE_keyframe_block);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 394;
                keyframe_selector();
                State = 405;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == COMMA)
                {
                    {
                        {
                            State = 395;
                            Match(COMMA);
                            State = 399;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (_la == S)
                            {
                                {
                                    {
                                        State = 396;
                                        Match(S);
                                    }
                                }
                                State = 401;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 402;
                            keyframe_selector();
                        }
                    }
                    State = 407;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 408;
                Match(LCURLY);
                State = 412;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 409;
                            Match(S);
                        }
                    }
                    State = 414;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 415;
                declarations();
                State = 416;
                Match(RCURLY);
            }
        }
        catch (RecognitionException re)
        {

            // log.debug("PARSING keyframe_selector ERROR | consume until RCURLY and add INVALID_STATEMENT");
            IntervalSet intervalSet = new IntervalSet(RCURLY);
            //we don't require {} to be balanced here because of possible parent 'media' sections that may remain open => RecoveryMode.RULE
            getCSSErrorHandler().consumeUntilGreedy(this, intervalSet/*, CSSLexerState.RecoveryMode.RULE*/);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Keyframe_selectorContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTAGE() { return GetToken(CSSParser.PERCENTAGE, 0); }
        public Keyframe_selectorContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_keyframe_selector; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterKeyframe_selector(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitKeyframe_selector(this);
        }
    }

    [RuleVersion(0)]
    public Keyframe_selectorContext keyframe_selector()
    {
        Keyframe_selectorContext _localctx = new Keyframe_selectorContext(Context, State);
        EnterRule(_localctx, 30, RULE_keyframe_selector);
        int _la;
        try
        {
            State = 432;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case IDENT:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 418;
                        Match(IDENT);
                        State = 422;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 419;
                                    Match(S);
                                }
                            }
                            State = 424;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                    break;
                case PERCENTAGE:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 425;
                        Match(PERCENTAGE);
                        State = 429;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 426;
                                    Match(S);
                                }
                            }
                            State = 431;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | keyframes_selector | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Unknown_atruleContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATKEYWORD() { return GetToken(CSSParser.ATKEYWORD, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public Unknown_atrule_bodyContext unknown_atrule_body()
        {
            return GetRuleContext<Unknown_atrule_bodyContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext[] any()
        {
            return GetRuleContexts<AnyContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext any(int i)
        {
            return GetRuleContext<AnyContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(CSSParser.SEMICOLON, 0); }
        public Unknown_atruleContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_unknown_atrule; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterUnknown_atrule(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitUnknown_atrule(this);
        }
    }

    [RuleVersion(0)]
    public Unknown_atruleContext unknown_atrule()
    {
        Unknown_atruleContext _localctx = new Unknown_atruleContext(Context, State);
        EnterRule(_localctx, 32, RULE_unknown_atrule);
        int _la;
        try
        {
            State = 462;
            ErrorHandler.Sync(this);
            switch (Interpreter.AdaptivePredict(TokenStream, 60, Context))
            {
                case 1:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 434;
                        Match(ATKEYWORD);
                        State = 438;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 435;
                                    Match(S);
                                }
                            }
                            State = 440;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 444;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (EXCLAMATION - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                        {
                            {
                                {
                                    State = 441;
                                    any();
                                }
                            }
                            State = 446;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 447;
                        unknown_atrule_body();
                    }
                    break;
                case 2:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 448;
                        Match(ATKEYWORD);
                        State = 452;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 449;
                                    Match(S);
                                }
                            }
                            State = 454;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 458;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (EXCLAMATION - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                        {
                            {
                                {
                                    State = 455;
                                    any();
                                }
                            }
                            State = 460;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 461;
                        Match(SEMICOLON);
                    }
                    break;
            }
        }
        catch (RecognitionException re)
        {
            // log.error("PARSING unknown_atrule ERROR - consume until RCURLY");
            IntervalSet intervalSet = new IntervalSet(RCURLY, SEMICOLON);
            getCSSErrorHandler().consumeUntilGreedy(this, intervalSet, CSSLexerState.RecoveryMode.BALANCED);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_ATSTATEMENT, "INVALID_ATSTATEMENT"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Unknown_atrule_bodyContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CSSParser.LCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public Unknown_atrule_bodyContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_unknown_atrule_body; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterUnknown_atrule_body(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitUnknown_atrule_body(this);
        }
    }

    [RuleVersion(0)]
    public Unknown_atrule_bodyContext unknown_atrule_body()
    {
        Unknown_atrule_bodyContext _localctx = new Unknown_atrule_bodyContext(Context, State);
        EnterRule(_localctx, 34, RULE_unknown_atrule_body);

        //the body is defined as empty so any content leads to recognition exception
        //in that case, the whole body is consumed and the rule is closed
        CSSLexerState begin = getCurrentLexerState(_localctx.Start);

        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 464;
                Match(LCURLY);
                State = 468;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 465;
                            Match(S);
                        }
                    }
                    State = 470;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 471;
                Match(RCURLY);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING unknown_atrule_body has some content | consume until RCURLY");
            IntervalSet follow = new IntervalSet(RCURLY); //recover on the rule end
            this.getCSSErrorHandler().consumeUntilGreedy(this, follow, CSSLexerState.RecoveryMode.DECL, begin);
            _localctx.AddErrorNode(this.TokenFactory.Create(RPAREN, "}")); //formally close the body

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class RulesetContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CSSParser.LCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationsContext declarations()
        {
            return GetRuleContext<DeclarationsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public Combined_selectorContext[] combined_selector()
        {
            return GetRuleContexts<Combined_selectorContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Combined_selectorContext combined_selector(int i)
        {
            return GetRuleContext<Combined_selectorContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CSSParser.COMMA); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode COMMA(int i)
        {
            return GetToken(CSSParser.COMMA, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public NoruleContext norule()
        {
            return GetRuleContext<NoruleContext>(0);
        }
        public RulesetContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_ruleset; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterRuleset(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitRuleset(this);
        }
    }

    [RuleVersion(0)]
    public RulesetContext ruleset()
    {
        RulesetContext _localctx = new RulesetContext(Context, State);
        EnterRule(_localctx, 36, RULE_ruleset);
        int _la;
        try
        {
            State = 502;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case INVALID_SELPART:
                case IDENT:
                case CLASSKEYWORD:
                case HASH:
                case COLON:
                case LCURLY:
                case LBRACKET:
                case ASTERISK:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 487;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        if (((((_la - 23)) & ~0x3f) == 0 && ((1L << (_la - 23)) & ((1L << (INVALID_SELPART - 23)) | (1L << (IDENT - 23)) | (1L << (CLASSKEYWORD - 23)) | (1L << (HASH - 23)) | (1L << (COLON - 23)) | (1L << (LBRACKET - 23)) | (1L << (ASTERISK - 23)))) != 0))
                        {
                            {
                                State = 473;
                                combined_selector();
                                State = 484;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                                while (_la == COMMA)
                                {
                                    {
                                        {
                                            State = 474;
                                            Match(COMMA);
                                            State = 478;
                                            ErrorHandler.Sync(this);
                                            _la = TokenStream.LA(1);
                                            while (_la == S)
                                            {
                                                {
                                                    {
                                                        State = 475;
                                                        Match(S);
                                                    }
                                                }
                                                State = 480;
                                                ErrorHandler.Sync(this);
                                                _la = TokenStream.LA(1);
                                            }
                                            State = 481;
                                            combined_selector();
                                        }
                                    }
                                    State = 486;
                                    ErrorHandler.Sync(this);
                                    _la = TokenStream.LA(1);
                                }
                            }
                        }

                        State = 489;
                        Match(LCURLY);
                        State = 493;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 490;
                                    Match(S);
                                }
                            }
                            State = 495;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 496;
                        declarations();
                        State = 497;
                        Match(RCURLY);
                    }
                    break;
                case INVALID_STRING:
                case STRING:
                case UNCLOSED_STRING:
                case NUMBER:
                case PERCENTAGE:
                case DIMENSION:
                case URI:
                case UNCLOSED_URI:
                case UNIRANGE:
                case COMMA:
                case QUESTION:
                case PERCENT:
                case EQUALS:
                case SLASH:
                case GREATER:
                case LESS:
                case RPAREN:
                case EXCLAMATION:
                case MINUS:
                case PLUS:
                case POUND:
                case AMPERSAND:
                case HAT:
                case INCLUDES:
                case DASHMATCH:
                case CTRL:
                case INVALID_TOKEN:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 499;
                        norule();

                        // log.debug("PARSING ruleset: norule encountered | consume until RCURLY and add INVALID_STATEMENT");
                        IntervalSet intervalSet = new IntervalSet(RCURLY);
                        //we don't require {} to be balanced here because of possible parent 'media' sections that may remain open => RecoveryMode.RULE
                        getCSSErrorHandler().consumeUntilGreedy(this, intervalSet/*, CSSLexerState.RecoveryMode.RULE*/);
                        _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));

                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.debug("PARSING ruleset ERROR | consume until RCURLY and add INVALID_STATEMENT");
            IntervalSet intervalSet = new IntervalSet(RCURLY);
            //we don't require {} to be balanced here because of possible parent 'media' sections that may remain open => RecoveryMode.RULE
            getCSSErrorHandler().consumeUntilGreedy(this, intervalSet/*, CSSLexerState.RecoveryMode.RULE*/);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class DeclarationsContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationContext[] declaration()
        {
            return GetRuleContexts<DeclarationContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public DeclarationContext declaration(int i)
        {
            return GetRuleContext<DeclarationContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(CSSParser.SEMICOLON); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode SEMICOLON(int i)
        {
            return GetToken(CSSParser.SEMICOLON, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public DeclarationsContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_declarations; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterDeclarations(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitDeclarations(this);
        }
    }

    [RuleVersion(0)]
    public DeclarationsContext declarations()
    {
        DeclarationsContext _localctx = new DeclarationsContext(Context, State);
        EnterRule(_localctx, 38, RULE_declarations);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 505;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INVALID_STRING) | (1L << IDENT) | (1L << CLASSKEYWORD) | (1L << STRING) | (1L << UNCLOSED_STRING) | (1L << HASH) | (1L << NUMBER) | (1L << PERCENTAGE) | (1L << DIMENSION) | (1L << URI) | (1L << UNCLOSED_URI) | (1L << COLON) | (1L << COMMA) | (1L << QUESTION) | (1L << PERCENT) | (1L << EQUALS) | (1L << SLASH) | (1L << GREATER) | (1L << LESS))) != 0) || ((((_la - 70)) & ~0x3f) == 0 && ((1L << (_la - 70)) & ((1L << (EXCLAMATION - 70)) | (1L << (MINUS - 70)) | (1L << (PLUS - 70)) | (1L << (ASTERISK - 70)) | (1L << (INCLUDES - 70)) | (1L << (DASHMATCH - 70)) | (1L << (CTRL - 70)) | (1L << (INVALID_TOKEN - 70)) | (1L << (STRING_CHAR - 70)))) != 0))
                {
                    {
                        State = 504;
                        declaration();
                    }
                }

                State = 519;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == SEMICOLON)
                {
                    {
                        {
                            State = 507;
                            Match(SEMICOLON);
                            State = 511;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (_la == S)
                            {
                                {
                                    {
                                        State = 508;
                                        Match(S);
                                    }
                                }
                                State = 513;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 515;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INVALID_STRING) | (1L << IDENT) | (1L << CLASSKEYWORD) | (1L << STRING) | (1L << UNCLOSED_STRING) | (1L << HASH) | (1L << NUMBER) | (1L << PERCENTAGE) | (1L << DIMENSION) | (1L << URI) | (1L << UNCLOSED_URI) | (1L << COLON) | (1L << COMMA) | (1L << QUESTION) | (1L << PERCENT) | (1L << EQUALS) | (1L << SLASH) | (1L << GREATER) | (1L << LESS))) != 0) || ((((_la - 70)) & ~0x3f) == 0 && ((1L << (_la - 70)) & ((1L << (EXCLAMATION - 70)) | (1L << (MINUS - 70)) | (1L << (PLUS - 70)) | (1L << (ASTERISK - 70)) | (1L << (INCLUDES - 70)) | (1L << (DASHMATCH - 70)) | (1L << (CTRL - 70)) | (1L << (INVALID_TOKEN - 70)) | (1L << (STRING_CHAR - 70)))) != 0))
                            {
                                {
                                    State = 514;
                                    declaration();
                                }
                            }

                        }
                    }
                    State = 521;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | declarations | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class DeclarationContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public PropertyContext property()
        {
            return GetRuleContext<PropertyContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public TermsContext terms()
        {
            return GetRuleContext<TermsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public ImportantContext important()
        {
            return GetRuleContext<ImportantContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public NopropContext noprop()
        {
            return GetRuleContext<NopropContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext[] any()
        {
            return GetRuleContexts<AnyContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext any(int i)
        {
            return GetRuleContext<AnyContext>(i);
        }
        public DeclarationContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_declaration; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterDeclaration(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitDeclaration(this);
        }
    }

    [RuleVersion(0)]
    public DeclarationContext declaration()
    {
        DeclarationContext _localctx = new DeclarationContext(Context, State);
        EnterRule(_localctx, 40, RULE_declaration);

        CSSLexerState begin = getCurrentLexerState(_localctx.Start);
        // log.debug("Decl begin: " + begin);

        int _la;
        try
        {
            State = 543;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case IDENT:
                case MINUS:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 522;
                        property();
                        State = 523;
                        Match(COLON);
                        State = 527;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 524;
                                    Match(S);
                                }
                            }
                            State = 529;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 531;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        if (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (INVALID_STATEMENT - 21)) | (1L << (IDENT - 21)) | (1L << (ATKEYWORD - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LCURLY - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (EXPRESSION - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                        {
                            {
                                State = 530;
                                terms();
                            }
                        }

                        State = 534;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        if (_la == EXCLAMATION)
                        {
                            {
                                State = 533;
                                important();
                            }
                        }

                    }
                    break;
                case INVALID_STRING:
                case CLASSKEYWORD:
                case STRING:
                case UNCLOSED_STRING:
                case HASH:
                case NUMBER:
                case PERCENTAGE:
                case DIMENSION:
                case URI:
                case UNCLOSED_URI:
                case COLON:
                case COMMA:
                case QUESTION:
                case PERCENT:
                case EQUALS:
                case SLASH:
                case GREATER:
                case LESS:
                case EXCLAMATION:
                case PLUS:
                case ASTERISK:
                case INCLUDES:
                case DASHMATCH:
                case CTRL:
                case INVALID_TOKEN:
                case STRING_CHAR:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 536;
                        noprop();
                        State = 540;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (EXCLAMATION - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                        {
                            {
                                {
                                    State = 537;
                                    any();
                                }
                            }
                            State = 542;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING declaration ERROR | consume until SEMICOLON, RCURLY");
            IntervalSet follow = new IntervalSet(SEMICOLON, RCURLY); //recover on the declaration end or rule end
                                                                     //not greedy - the final ; or } must remain for properly finishing the declaration/rule
            this.getCSSErrorHandler().consumeUntil(this, follow, CSSLexerState.RecoveryMode.DECL, begin);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_DECLARATION, "INVALID_DECLARATION"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class ImportantContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION() { return GetToken(CSSParser.EXCLAMATION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPORTANT() { return GetToken(CSSParser.IMPORTANT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public ImportantContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_important; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterImportant(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitImportant(this);
        }
    }

    [RuleVersion(0)]
    public ImportantContext important()
    {
        ImportantContext _localctx = new ImportantContext(Context, State);
        EnterRule(_localctx, 42, RULE_important);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 545;
                Match(EXCLAMATION);
                State = 549;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 546;
                            Match(S);
                        }
                    }
                    State = 551;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 552;
                Match(IMPORTANT);
                State = 556;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 553;
                            Match(S);
                        }
                    }
                    State = 558;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING IMPORTANT error");
            IntervalSet intervalSet = new IntervalSet(RCURLY, SEMICOLON);
            this.getCSSErrorHandler().consumeUntil(this, intervalSet, CSSLexerState.RecoveryMode.RULE, null);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_DIRECTIVE, "INVALID_DIRECTIVE"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class PropertyContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public PropertyContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_property; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterProperty(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitProperty(this);
        }
    }

    [RuleVersion(0)]
    public PropertyContext property()
    {
        PropertyContext _localctx = new PropertyContext(Context, State);
        EnterRule(_localctx, 44, RULE_property);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 560;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                if (_la == MINUS)
                {
                    {
                        State = 559;
                        Match(MINUS);
                    }
                }

                State = 562;
                Match(IDENT);
                State = 566;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 563;
                            Match(S);
                        }
                    }
                    State = 568;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING property ERROR | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class TermsContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public TermContext[] term()
        {
            return GetRuleContexts<TermContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public TermContext term(int i)
        {
            return GetRuleContext<TermContext>(i);
        }
        public TermsContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_terms; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterTerms(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitTerms(this);
        }
    }

    [RuleVersion(0)]
    public TermsContext terms()
    {
        TermsContext _localctx = new TermsContext(Context, State);
        EnterRule(_localctx, 46, RULE_terms);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 570;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                do
                {
                    {
                        {
                            State = 569;
                            term();
                        }
                    }
                    State = 572;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                } while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (INVALID_STATEMENT - 21)) | (1L << (IDENT - 21)) | (1L << (ATKEYWORD - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LCURLY - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (EXPRESSION - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0));
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING terms ERROR functLevel = {}", functLevel);
            if (functLevel == 0)
            {
                IntervalSet intervalSet = new IntervalSet(RCURLY, SEMICOLON);
                this.getCSSErrorHandler().consumeUntilGreedy(this, intervalSet);
                _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));
            }
            else
            {
                IntervalSet intervalSet = new IntervalSet(RPAREN, RCURLY, SEMICOLON);
                this.getCSSErrorHandler().consumeUntilGreedy(this, intervalSet, CSSLexerState.RecoveryMode.FUNCTION);
                _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));
            }

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class TermContext : ParserRuleContext
    {
        public TermContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_term; } }

        public TermContext() { }
        public virtual void CopyFrom(TermContext context)
        {
            base.CopyFrom(context);
        }
    }
    public partial class TermValuePartContext : TermContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public ValuepartContext valuepart()
        {
            return GetRuleContext<ValuepartContext>(0);
        }
        public TermValuePartContext(TermContext context) { CopyFrom(context); }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterTermValuePart(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitTermValuePart(this);
        }
    }
    public partial class TermInvalidContext : TermContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CSSParser.LCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext[] any()
        {
            return GetRuleContexts<AnyContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext any(int i)
        {
            return GetRuleContext<AnyContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(CSSParser.SEMICOLON); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode SEMICOLON(int i)
        {
            return GetToken(CSSParser.SEMICOLON, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATKEYWORD() { return GetToken(CSSParser.ATKEYWORD, 0); }
        public TermInvalidContext(TermContext context) { CopyFrom(context); }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterTermInvalid(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitTermInvalid(this);
        }
    }

    [RuleVersion(0)]
    public TermContext term()
    {
        TermContext _localctx = new TermContext(Context, State);
        EnterRule(_localctx, 48, RULE_term);
        int _la;
        try
        {
            State = 603;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case INVALID_STRING:
                case INVALID_STATEMENT:
                case IDENT:
                case CLASSKEYWORD:
                case STRING:
                case UNCLOSED_STRING:
                case HASH:
                case NUMBER:
                case PERCENTAGE:
                case DIMENSION:
                case URI:
                case UNCLOSED_URI:
                case UNIRANGE:
                case COLON:
                case COMMA:
                case QUESTION:
                case PERCENT:
                case EQUALS:
                case SLASH:
                case GREATER:
                case LESS:
                case LPAREN:
                case LBRACKET:
                case MINUS:
                case PLUS:
                case ASTERISK:
                case EXPRESSION:
                case FUNCTION:
                case INCLUDES:
                case DASHMATCH:
                    _localctx = new TermValuePartContext(_localctx);
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 574;
                        valuepart();
                    }
                    break;
                case LCURLY:
                    _localctx = new TermInvalidContext(_localctx);
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 575;
                        Match(LCURLY);
                        State = 579;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 576;
                                    Match(S);
                                }
                            }
                            State = 581;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 592;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (SEMICOLON - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (EXCLAMATION - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                        {
                            {
                                State = 590;
                                ErrorHandler.Sync(this);
                                switch (TokenStream.LA(1))
                                {
                                    case INVALID_STRING:
                                    case IDENT:
                                    case CLASSKEYWORD:
                                    case STRING:
                                    case UNCLOSED_STRING:
                                    case HASH:
                                    case NUMBER:
                                    case PERCENTAGE:
                                    case DIMENSION:
                                    case URI:
                                    case UNCLOSED_URI:
                                    case UNIRANGE:
                                    case COLON:
                                    case COMMA:
                                    case QUESTION:
                                    case PERCENT:
                                    case EQUALS:
                                    case SLASH:
                                    case GREATER:
                                    case LESS:
                                    case LPAREN:
                                    case LBRACKET:
                                    case EXCLAMATION:
                                    case MINUS:
                                    case PLUS:
                                    case ASTERISK:
                                    case FUNCTION:
                                    case INCLUDES:
                                    case DASHMATCH:
                                        {
                                            State = 582;
                                            any();
                                        }
                                        break;
                                    case SEMICOLON:
                                        {
                                            State = 583;
                                            Match(SEMICOLON);
                                            State = 587;
                                            ErrorHandler.Sync(this);
                                            _la = TokenStream.LA(1);
                                            while (_la == S)
                                            {
                                                {
                                                    {
                                                        State = 584;
                                                        Match(S);
                                                    }
                                                }
                                                State = 589;
                                                ErrorHandler.Sync(this);
                                                _la = TokenStream.LA(1);
                                            }
                                        }
                                        break;
                                    default:
                                        throw new NoViableAltException(this);
                                }
                            }
                            State = 594;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 595;
                        Match(RCURLY);
                    }
                    break;
                case ATKEYWORD:
                    _localctx = new TermInvalidContext(_localctx);
                    EnterOuterAlt(_localctx, 3);
                    {
                        State = 596;
                        Match(ATKEYWORD);
                        State = 600;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 597;
                                    Match(S);
                                }
                            }
                            State = 602;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING term ERROR | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class FunctContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXPRESSION() { return GetToken(CSSParser.EXPRESSION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext[] any()
        {
            return GetRuleContexts<AnyContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext any(int i)
        {
            return GetRuleContext<AnyContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(CSSParser.SEMICOLON); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode SEMICOLON(int i)
        {
            return GetToken(CSSParser.SEMICOLON, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(CSSParser.FUNCTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public Funct_argsContext funct_args()
        {
            return GetRuleContext<Funct_argsContext>(0);
        }
        public FunctContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_funct; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterFunct(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitFunct(this);
        }
    }

    [RuleVersion(0)]
    public FunctContext funct()
    {
        FunctContext _localctx = new FunctContext(Context, State);
        EnterRule(_localctx, 50, RULE_funct);

        functLevel++;

        int _la;
        try
        {
            State = 637;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case EXPRESSION:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 605;
                        Match(EXPRESSION);
                        State = 609;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 606;
                                    Match(S);
                                }
                            }
                            State = 611;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 622;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (SEMICOLON - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (EXCLAMATION - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                        {
                            {
                                State = 620;
                                ErrorHandler.Sync(this);
                                switch (TokenStream.LA(1))
                                {
                                    case INVALID_STRING:
                                    case IDENT:
                                    case CLASSKEYWORD:
                                    case STRING:
                                    case UNCLOSED_STRING:
                                    case HASH:
                                    case NUMBER:
                                    case PERCENTAGE:
                                    case DIMENSION:
                                    case URI:
                                    case UNCLOSED_URI:
                                    case UNIRANGE:
                                    case COLON:
                                    case COMMA:
                                    case QUESTION:
                                    case PERCENT:
                                    case EQUALS:
                                    case SLASH:
                                    case GREATER:
                                    case LESS:
                                    case LPAREN:
                                    case LBRACKET:
                                    case EXCLAMATION:
                                    case MINUS:
                                    case PLUS:
                                    case ASTERISK:
                                    case FUNCTION:
                                    case INCLUDES:
                                    case DASHMATCH:
                                        {
                                            State = 612;
                                            any();
                                        }
                                        break;
                                    case SEMICOLON:
                                        {
                                            State = 613;
                                            Match(SEMICOLON);
                                            State = 617;
                                            ErrorHandler.Sync(this);
                                            _la = TokenStream.LA(1);
                                            while (_la == S)
                                            {
                                                {
                                                    {
                                                        State = 614;
                                                        Match(S);
                                                    }
                                                }
                                                State = 619;
                                                ErrorHandler.Sync(this);
                                                _la = TokenStream.LA(1);
                                            }
                                        }
                                        break;
                                    default:
                                        throw new NoViableAltException(this);
                                }
                            }
                            State = 624;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 625;
                        Match(RPAREN);
                    }
                    break;
                case FUNCTION:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 626;
                        Match(FUNCTION);
                        State = 630;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 627;
                                    Match(S);
                                }
                            }
                            State = 632;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 634;
                        ErrorHandler.Sync(this);
                        switch (Interpreter.AdaptivePredict(TokenStream, 92, Context))
                        {
                            case 1:
                                {
                                    State = 633;
                                    funct_args();
                                }
                                break;
                        }
                        State = 636;
                        Match(RPAREN);
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
            Context.Stop = TokenStream.LT(-1);

            functLevel--;

        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | funct | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class ValuepartContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(CSSParser.NUMBER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTAGE() { return GetToken(CSSParser.PERCENTAGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIMENSION() { return GetToken(CSSParser.DIMENSION, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public StringContext stringv()
        {
            return GetRuleContext<StringContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URI() { return GetToken(CSSParser.URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCLOSED_URI() { return GetToken(CSSParser.UNCLOSED_URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(CSSParser.HASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public FunctContext funct()
        {
            return GetRuleContext<FunctContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CSSParser.COMMA, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLASH() { return GetToken(CSSParser.SLASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public Bracketed_identsContext bracketed_idents()
        {
            return GetRuleContext<Bracketed_identsContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLASSKEYWORD() { return GetToken(CSSParser.CLASSKEYWORD, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIRANGE() { return GetToken(CSSParser.UNIRANGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDES() { return GetToken(CSSParser.INCLUDES, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(CSSParser.GREATER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(CSSParser.LESS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION() { return GetToken(CSSParser.QUESTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(CSSParser.PERCENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUALS() { return GetToken(CSSParser.EQUALS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CSSParser.ASTERISK, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DASHMATCH() { return GetToken(CSSParser.DASHMATCH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CSSParser.LPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ValuepartContext[] valuepart()
        {
            return GetRuleContexts<ValuepartContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public ValuepartContext valuepart(int i)
        {
            return GetRuleContext<ValuepartContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
        public ValuepartContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_valuepart; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterValuepart(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitValuepart(this);
        }
    }

    [RuleVersion(0)]
    public ValuepartContext valuepart()
    {
        ValuepartContext _localctx = new ValuepartContext(Context, State);
        EnterRule(_localctx, 52, RULE_valuepart);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 685;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 100, Context))
                {
                    case 1:
                        {
                            State = 640;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == MINUS)
                            {
                                {
                                    State = 639;
                                    Match(MINUS);
                                }
                            }

                            State = 642;
                            Match(IDENT);
                        }
                        break;
                    case 2:
                        {
                            State = 644;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == MINUS || _la == PLUS)
                            {
                                {
                                    State = 643;
                                    _la = TokenStream.LA(1);
                                    if (!(_la == MINUS || _la == PLUS))
                                    {
                                        ErrorHandler.RecoverInline(this);
                                    }
                                    else
                                    {
                                        ErrorHandler.ReportMatch(this);
                                        Consume();
                                    }
                                }
                            }

                            State = 646;
                            Match(NUMBER);
                        }
                        break;
                    case 3:
                        {
                            State = 648;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == MINUS || _la == PLUS)
                            {
                                {
                                    State = 647;
                                    _la = TokenStream.LA(1);
                                    if (!(_la == MINUS || _la == PLUS))
                                    {
                                        ErrorHandler.RecoverInline(this);
                                    }
                                    else
                                    {
                                        ErrorHandler.ReportMatch(this);
                                        Consume();
                                    }
                                }
                            }

                            State = 650;
                            Match(PERCENTAGE);
                        }
                        break;
                    case 4:
                        {
                            State = 652;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == MINUS || _la == PLUS)
                            {
                                {
                                    State = 651;
                                    _la = TokenStream.LA(1);
                                    if (!(_la == MINUS || _la == PLUS))
                                    {
                                        ErrorHandler.RecoverInline(this);
                                    }
                                    else
                                    {
                                        ErrorHandler.ReportMatch(this);
                                        Consume();
                                    }
                                }
                            }

                            State = 654;
                            Match(DIMENSION);
                        }
                        break;
                    case 5:
                        {
                            State = 655;
                            stringv();
                        }
                        break;
                    case 6:
                        {
                            State = 656;
                            Match(URI);
                        }
                        break;
                    case 7:
                        {
                            State = 657;
                            Match(UNCLOSED_URI);
                        }
                        break;
                    case 8:
                        {
                            State = 658;
                            Match(HASH);
                        }
                        break;
                    case 9:
                        {
                            State = 660;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == MINUS || _la == PLUS)
                            {
                                {
                                    State = 659;
                                    _la = TokenStream.LA(1);
                                    if (!(_la == MINUS || _la == PLUS))
                                    {
                                        ErrorHandler.RecoverInline(this);
                                    }
                                    else
                                    {
                                        ErrorHandler.ReportMatch(this);
                                        Consume();
                                    }
                                }
                            }

                            State = 662;
                            funct();
                        }
                        break;
                    case 10:
                        {
                            State = 663;
                            Match(COMMA);
                        }
                        break;
                    case 11:
                        {
                            State = 664;
                            Match(SLASH);
                        }
                        break;
                    case 12:
                        {
                            State = 665;
                            bracketed_idents();
                        }
                        break;
                    case 13:
                        {
                            State = 666;
                            Match(CLASSKEYWORD);
                        }
                        break;
                    case 14:
                        {
                            State = 667;
                            Match(UNIRANGE);
                        }
                        break;
                    case 15:
                        {
                            State = 668;
                            Match(INCLUDES);
                        }
                        break;
                    case 16:
                        {
                            State = 669;
                            Match(COLON);
                        }
                        break;
                    case 17:
                        {
                            State = 670;
                            Match(GREATER);
                        }
                        break;
                    case 18:
                        {
                            State = 671;
                            Match(LESS);
                        }
                        break;
                    case 19:
                        {
                            State = 672;
                            Match(QUESTION);
                        }
                        break;
                    case 20:
                        {
                            State = 673;
                            Match(PERCENT);
                        }
                        break;
                    case 21:
                        {
                            State = 674;
                            Match(EQUALS);
                        }
                        break;
                    case 22:
                        {
                            State = 675;
                            Match(ASTERISK);
                        }
                        break;
                    case 23:
                        {
                            State = 676;
                            Match(DASHMATCH);
                        }
                        break;
                    case 24:
                        {
                            State = 677;
                            Match(LPAREN);
                            State = 681;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (INVALID_STATEMENT - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (EXPRESSION - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                            {
                                {
                                    {
                                        State = 678;
                                        valuepart();
                                    }
                                }
                                State = 683;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 684;
                            Match(RPAREN);
                        }
                        break;
                }
                State = 690;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 687;
                            Match(S);
                        }
                    }
                    State = 692;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | valuepart");
            IntervalSet intervalSet = new IntervalSet(RCURLY, SEMICOLON);
            getCSSErrorHandler().consumeUntil(this, intervalSet, CSSLexerState.RecoveryMode.NOBALANCE, null);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, ""));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Funct_argsContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public Funct_argumentContext[] funct_argument()
        {
            return GetRuleContexts<Funct_argumentContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Funct_argumentContext funct_argument(int i)
        {
            return GetRuleContext<Funct_argumentContext>(i);
        }
        public Funct_argsContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_funct_args; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterFunct_args(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitFunct_args(this);
        }
    }

    [RuleVersion(0)]
    public Funct_argsContext funct_args()
    {
        Funct_argsContext _localctx = new Funct_argsContext(Context, State);
        EnterRule(_localctx, 54, RULE_funct_args);
        try
        {
            int _alt;
            EnterOuterAlt(_localctx, 1);
            {
                State = 694;
                ErrorHandler.Sync(this);
                _alt = 1;
                do
                {
                    switch (_alt)
                    {
                        case 1:
                            {
                                {
                                    State = 693;
                                    funct_argument();
                                }
                            }
                            break;
                        default:
                            throw new NoViableAltException(this);
                    }
                    State = 696;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 102, Context);
                } while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING funct_args ERROR functLevel = {}", functLevel);
            IntervalSet intervalSet = new IntervalSet(RPAREN, RCURLY, SEMICOLON);
            this.getCSSErrorHandler().consumeUntilGreedy(this, intervalSet, CSSLexerState.RecoveryMode.FUNCTION);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, "INVALID_STATEMENT"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Funct_argumentContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CSSParser.ASTERISK, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLASH() { return GetToken(CSSParser.SLASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CSSParser.LPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(CSSParser.NUMBER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTAGE() { return GetToken(CSSParser.PERCENTAGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIMENSION() { return GetToken(CSSParser.DIMENSION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(CSSParser.HASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public StringContext stringv()
        {
            return GetRuleContext<StringContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public FunctContext funct()
        {
            return GetRuleContext<FunctContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CSSParser.COMMA, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLASSKEYWORD() { return GetToken(CSSParser.CLASSKEYWORD, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIRANGE() { return GetToken(CSSParser.UNIRANGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDES() { return GetToken(CSSParser.INCLUDES, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(CSSParser.GREATER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(CSSParser.LESS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION() { return GetToken(CSSParser.QUESTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(CSSParser.PERCENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUALS() { return GetToken(CSSParser.EQUALS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DASHMATCH() { return GetToken(CSSParser.DASHMATCH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public Funct_argumentContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_funct_argument; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterFunct_argument(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitFunct_argument(this);
        }
    }

    [RuleVersion(0)]
    public Funct_argumentContext funct_argument()
    {
        Funct_argumentContext _localctx = new Funct_argumentContext(Context, State);
        EnterRule(_localctx, 56, RULE_funct_argument);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 722;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1))
                {
                    case IDENT:
                        {
                            State = 698;
                            Match(IDENT);
                        }
                        break;
                    case PLUS:
                        {
                            State = 699;
                            Match(PLUS);
                        }
                        break;
                    case MINUS:
                        {
                            State = 700;
                            Match(MINUS);
                        }
                        break;
                    case ASTERISK:
                        {
                            State = 701;
                            Match(ASTERISK);
                        }
                        break;
                    case SLASH:
                        {
                            State = 702;
                            Match(SLASH);
                        }
                        break;
                    case LPAREN:
                        {
                            State = 703;
                            Match(LPAREN);
                        }
                        break;
                    case RPAREN:
                        {
                            State = 704;
                            Match(RPAREN);
                        }
                        break;
                    case NUMBER:
                        {
                            State = 705;
                            Match(NUMBER);
                        }
                        break;
                    case PERCENTAGE:
                        {
                            State = 706;
                            Match(PERCENTAGE);
                        }
                        break;
                    case DIMENSION:
                        {
                            State = 707;
                            Match(DIMENSION);
                        }
                        break;
                    case HASH:
                        {
                            State = 708;
                            Match(HASH);
                        }
                        break;
                    case INVALID_STRING:
                    case STRING:
                    case UNCLOSED_STRING:
                        {
                            State = 709;
                            stringv();
                        }
                        break;
                    case EXPRESSION:
                    case FUNCTION:
                        {
                            State = 710;
                            funct();
                        }
                        break;
                    case COMMA:
                        {
                            State = 711;
                            Match(COMMA);
                        }
                        break;
                    case CLASSKEYWORD:
                        {
                            State = 712;
                            Match(CLASSKEYWORD);
                        }
                        break;
                    case UNIRANGE:
                        {
                            State = 713;
                            Match(UNIRANGE);
                        }
                        break;
                    case INCLUDES:
                        {
                            State = 714;
                            Match(INCLUDES);
                        }
                        break;
                    case COLON:
                        {
                            State = 715;
                            Match(COLON);
                        }
                        break;
                    case GREATER:
                        {
                            State = 716;
                            Match(GREATER);
                        }
                        break;
                    case LESS:
                        {
                            State = 717;
                            Match(LESS);
                        }
                        break;
                    case QUESTION:
                        {
                            State = 718;
                            Match(QUESTION);
                        }
                        break;
                    case PERCENT:
                        {
                            State = 719;
                            Match(PERCENT);
                        }
                        break;
                    case EQUALS:
                        {
                            State = 720;
                            Match(EQUALS);
                        }
                        break;
                    case DASHMATCH:
                        {
                            State = 721;
                            Match(DASHMATCH);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
                State = 727;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 724;
                            Match(S);
                        }
                    }
                    State = 729;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | funct_argument");
            IntervalSet intervalSet = new IntervalSet(RCURLY, SEMICOLON);
            getCSSErrorHandler().consumeUntil(this, intervalSet, CSSLexerState.RecoveryMode.BALANCED, null);
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, ""));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Combined_selectorContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode]
        public SelectorContext[] selector()
        {
            return GetRuleContexts<SelectorContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public SelectorContext selector(int i)
        {
            return GetRuleContext<SelectorContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public CombinatorContext[] combinator()
        {
            return GetRuleContexts<CombinatorContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public CombinatorContext combinator(int i)
        {
            return GetRuleContext<CombinatorContext>(i);
        }
        public Combined_selectorContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_combined_selector; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterCombined_selector(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitCombined_selector(this);
        }
    }

    [RuleVersion(0)]
    public Combined_selectorContext combined_selector()
    {
        Combined_selectorContext _localctx = new Combined_selectorContext(Context, State);
        EnterRule(_localctx, 58, RULE_combined_selector);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 730;
                selector();
                State = 736;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (((((_la - 60)) & ~0x3f) == 0 && ((1L << (_la - 60)) & ((1L << (GREATER - 60)) | (1L << (TILDE - 60)) | (1L << (PLUS - 60)) | (1L << (S - 60)))) != 0))
                {
                    {
                        {
                            {
                                State = 731;
                                combinator();
                            }
                            State = 732;
                            selector();
                        }
                    }
                    State = 738;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | combined_selector | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class CombinatorContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(CSSParser.GREATER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TILDE() { return GetToken(CSSParser.TILDE, 0); }
        public CombinatorContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_combinator; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterCombinator(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitCombinator(this);
        }
    }

    [RuleVersion(0)]
    public CombinatorContext combinator()
    {
        CombinatorContext _localctx = new CombinatorContext(Context, State);
        EnterRule(_localctx, 60, RULE_combinator);
        int _la;
        try
        {
            State = 761;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case GREATER:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 739;
                        Match(GREATER);
                        State = 743;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 740;
                                    Match(S);
                                }
                            }
                            State = 745;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                    break;
                case PLUS:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 746;
                        Match(PLUS);
                        State = 750;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 747;
                                    Match(S);
                                }
                            }
                            State = 752;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                    break;
                case TILDE:
                    EnterOuterAlt(_localctx, 3);
                    {
                        State = 753;
                        Match(TILDE);
                        State = 757;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 754;
                                    Match(S);
                                }
                            }
                            State = 759;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                    break;
                case S:
                    EnterOuterAlt(_localctx, 4);
                    {
                        State = 760;
                        Match(S);
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | combinator| should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class SelectorContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CSSParser.ASTERISK, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public SelpartContext[] selpart()
        {
            return GetRuleContexts<SelpartContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public SelpartContext selpart(int i)
        {
            return GetRuleContext<SelpartContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public SelectorContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_selector; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterSelector(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitSelector(this);
        }
    }

    [RuleVersion(0)]
    public SelectorContext selector()
    {
        SelectorContext _localctx = new SelectorContext(Context, State);
        EnterRule(_localctx, 62, RULE_selector);
        int _la;
        try
        {
            int _alt;
            State = 787;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case IDENT:
                case ASTERISK:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 763;
                        _la = TokenStream.LA(1);
                        if (!(_la == IDENT || _la == ASTERISK))
                        {
                            ErrorHandler.RecoverInline(this);
                        }
                        else
                        {
                            ErrorHandler.ReportMatch(this);
                            Consume();
                        }
                        State = 767;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (((((_la - 23)) & ~0x3f) == 0 && ((1L << (_la - 23)) & ((1L << (INVALID_SELPART - 23)) | (1L << (CLASSKEYWORD - 23)) | (1L << (HASH - 23)) | (1L << (COLON - 23)) | (1L << (LBRACKET - 23)))) != 0))
                        {
                            {
                                {
                                    State = 764;
                                    selpart();
                                }
                            }
                            State = 769;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 773;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 111, Context);
                        while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                        {
                            if (_alt == 1)
                            {
                                {
                                    {
                                        State = 770;
                                        Match(S);
                                    }
                                }
                            }
                            State = 775;
                            ErrorHandler.Sync(this);
                            _alt = Interpreter.AdaptivePredict(TokenStream, 111, Context);
                        }
                    }
                    break;
                case INVALID_SELPART:
                case CLASSKEYWORD:
                case HASH:
                case COLON:
                case LBRACKET:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 777;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        do
                        {
                            {
                                {
                                    State = 776;
                                    selpart();
                                }
                            }
                            State = 779;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        } while (((((_la - 23)) & ~0x3f) == 0 && ((1L << (_la - 23)) & ((1L << (INVALID_SELPART - 23)) | (1L << (CLASSKEYWORD - 23)) | (1L << (HASH - 23)) | (1L << (COLON - 23)) | (1L << (LBRACKET - 23)))) != 0));
                        State = 784;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 113, Context);
                        while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER)
                        {
                            if (_alt == 1)
                            {
                                {
                                    {
                                        State = 781;
                                        Match(S);
                                    }
                                }
                            }
                            State = 786;
                            ErrorHandler.Sync(this);
                            _alt = Interpreter.AdaptivePredict(TokenStream, 113, Context);
                        }
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING selector ERROR | inserting INVALID_SELECTOR");
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_SELECTOR, "INVALID_SELECTOR"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class SelpartContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(CSSParser.HASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLASSKEYWORD() { return GetToken(CSSParser.CLASSKEYWORD, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CSSParser.LBRACKET, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public AttributeContext attribute()
        {
            return GetRuleContext<AttributeContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CSSParser.RBRACKET, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public PseudoContext pseudo()
        {
            return GetRuleContext<PseudoContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALID_SELPART() { return GetToken(CSSParser.INVALID_SELPART, 0); }
        public SelpartContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_selpart; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterSelpart(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitSelpart(this);
        }
    }

    [RuleVersion(0)]
    public SelpartContext selpart()
    {
        SelpartContext _localctx = new SelpartContext(Context, State);
        EnterRule(_localctx, 64, RULE_selpart);
        int _la;
        try
        {
            State = 803;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case HASH:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 789;
                        Match(HASH);
                    }
                    break;
                case CLASSKEYWORD:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 790;
                        Match(CLASSKEYWORD);
                    }
                    break;
                case LBRACKET:
                    EnterOuterAlt(_localctx, 3);
                    {
                        State = 791;
                        Match(LBRACKET);
                        State = 795;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 792;
                                    Match(S);
                                }
                            }
                            State = 797;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 798;
                        attribute();
                        State = 799;
                        Match(RBRACKET);
                    }
                    break;
                case COLON:
                    EnterOuterAlt(_localctx, 4);
                    {
                        State = 801;
                        pseudo();
                    }
                    break;
                case INVALID_SELPART:
                    EnterOuterAlt(_localctx, 5);
                    {
                        State = 802;
                        Match(INVALID_SELPART);
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING SELPART ERROR");
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_SELPART, "INVALID_SELPART"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class AttributeContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] IDENT() { return GetTokens(CSSParser.IDENT); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode IDENT(int i)
        {
            return GetToken(CSSParser.IDENT, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUALS() { return GetToken(CSSParser.EQUALS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDES() { return GetToken(CSSParser.INCLUDES, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DASHMATCH() { return GetToken(CSSParser.DASHMATCH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STARTSWITH() { return GetToken(CSSParser.STARTSWITH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDSWITH() { return GetToken(CSSParser.ENDSWITH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTAINS() { return GetToken(CSSParser.CONTAINS, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public StringContext stringv()
        {
            return GetRuleContext<StringContext>(0);
        }
        public AttributeContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_attribute; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterAttribute(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitAttribute(this);
        }
    }

    [RuleVersion(0)]
    public AttributeContext attribute()
    {
        AttributeContext _localctx = new AttributeContext(Context, State);
        EnterRule(_localctx, 66, RULE_attribute);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 805;
                Match(IDENT);
                State = 809;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 806;
                            Match(S);
                        }
                    }
                    State = 811;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
                State = 829;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                if (((((_la - 58)) & ~0x3f) == 0 && ((1L << (_la - 58)) & ((1L << (EQUALS - 58)) | (1L << (INCLUDES - 58)) | (1L << (DASHMATCH - 58)) | (1L << (STARTSWITH - 58)) | (1L << (ENDSWITH - 58)) | (1L << (CONTAINS - 58)))) != 0))
                {
                    {
                        State = 812;
                        _la = TokenStream.LA(1);
                        if (!(((((_la - 58)) & ~0x3f) == 0 && ((1L << (_la - 58)) & ((1L << (EQUALS - 58)) | (1L << (INCLUDES - 58)) | (1L << (DASHMATCH - 58)) | (1L << (STARTSWITH - 58)) | (1L << (ENDSWITH - 58)) | (1L << (CONTAINS - 58)))) != 0)))
                        {
                            ErrorHandler.RecoverInline(this);
                        }
                        else
                        {
                            ErrorHandler.ReportMatch(this);
                            Consume();
                        }
                        State = 816;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 813;
                                    Match(S);
                                }
                            }
                            State = 818;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 821;
                        ErrorHandler.Sync(this);
                        switch (TokenStream.LA(1))
                        {
                            case IDENT:
                                {
                                    State = 819;
                                    Match(IDENT);
                                }
                                break;
                            case INVALID_STRING:
                            case STRING:
                            case UNCLOSED_STRING:
                                {
                                    State = 820;
                                    stringv();
                                }
                                break;
                            default:
                                throw new NoViableAltException(this);
                        }
                        State = 826;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 823;
                                    Match(S);
                                }
                            }
                            State = 828;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                }

            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | attribute | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class PseudoContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COLON() { return GetTokens(CSSParser.COLON); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode COLON(int i)
        {
            return GetToken(CSSParser.COLON, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(CSSParser.FUNCTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(CSSParser.NUMBER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(CSSParser.INDEX, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public SelectorContext selector()
        {
            return GetRuleContext<SelectorContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public PseudoContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_pseudo; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterPseudo(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitPseudo(this);
        }
    }

    [RuleVersion(0)]
    public PseudoContext pseudo()
    {
        PseudoContext _localctx = new PseudoContext(Context, State);
        EnterRule(_localctx, 68, RULE_pseudo);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 831;
                Match(COLON);
                State = 833;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                if (_la == COLON)
                {
                    {
                        State = 832;
                        Match(COLON);
                    }
                }

                State = 868;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1))
                {
                    case IDENT:
                    case MINUS:
                        {
                            State = 836;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == MINUS)
                            {
                                {
                                    State = 835;
                                    Match(MINUS);
                                }
                            }

                            State = 838;
                            Match(IDENT);
                        }
                        break;
                    case FUNCTION:
                        {
                            State = 839;
                            Match(FUNCTION);
                            State = 843;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (_la == S)
                            {
                                {
                                    {
                                        State = 840;
                                        Match(S);
                                    }
                                }
                                State = 845;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 859;
                            ErrorHandler.Sync(this);
                            switch (Interpreter.AdaptivePredict(TokenStream, 128, Context))
                            {
                                case 1:
                                    {
                                        State = 847;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.LA(1);
                                        if (_la == MINUS)
                                        {
                                            {
                                                State = 846;
                                                Match(MINUS);
                                            }
                                        }

                                        State = 849;
                                        Match(IDENT);
                                    }
                                    break;
                                case 2:
                                    {
                                        State = 851;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.LA(1);
                                        if (_la == MINUS)
                                        {
                                            {
                                                State = 850;
                                                Match(MINUS);
                                            }
                                        }

                                        State = 853;
                                        Match(NUMBER);
                                    }
                                    break;
                                case 3:
                                    {
                                        State = 855;
                                        ErrorHandler.Sync(this);
                                        _la = TokenStream.LA(1);
                                        if (_la == MINUS)
                                        {
                                            {
                                                State = 854;
                                                Match(MINUS);
                                            }
                                        }

                                        State = 857;
                                        Match(INDEX);
                                    }
                                    break;
                                case 4:
                                    {
                                        State = 858;
                                        selector();
                                    }
                                    break;
                            }
                            State = 864;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (_la == S)
                            {
                                {
                                    {
                                        State = 861;
                                        Match(S);
                                    }
                                }
                                State = 866;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 867;
                            Match(RPAREN);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING pseudo ERROR | inserting INVALID_SELPART");
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_SELPART, "INVALID_SELPART"));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class StringContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(CSSParser.STRING, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCLOSED_STRING() { return GetToken(CSSParser.UNCLOSED_STRING, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALID_STRING() { return GetToken(CSSParser.INVALID_STRING, 0); }
        public StringContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_string; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterString(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitString(this);
        }
    }

    [RuleVersion(0)]
    public StringContext stringv()
    {
        StringContext _localctx = new StringContext(Context, State);
        EnterRule(_localctx, 70, RULE_string);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 870;
                _la = TokenStream.LA(1);
                if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << INVALID_STRING) | (1L << STRING) | (1L << UNCLOSED_STRING))) != 0)))
                {
                    ErrorHandler.RecoverInline(this);
                }
                else
                {
                    ErrorHandler.ReportMatch(this);
                    Consume();
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING string ERROR | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Bracketed_identsContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CSSParser.LBRACKET, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CSSParser.RBRACKET, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Ident_list_itemContext[] ident_list_item()
        {
            return GetRuleContexts<Ident_list_itemContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public Ident_list_itemContext ident_list_item(int i)
        {
            return GetRuleContext<Ident_list_itemContext>(i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALID_STATEMENT() { return GetToken(CSSParser.INVALID_STATEMENT, 0); }
        public Bracketed_identsContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_bracketed_idents; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterBracketed_idents(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitBracketed_idents(this);
        }
    }

    [RuleVersion(0)]
    public Bracketed_identsContext bracketed_idents()
    {
        Bracketed_identsContext _localctx = new Bracketed_identsContext(Context, State);
        EnterRule(_localctx, 72, RULE_bracketed_idents);
        int _la;
        try
        {
            State = 887;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case LBRACKET:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 872;
                        Match(LBRACKET);
                        State = 876;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 873;
                                    Match(S);
                                }
                            }
                            State = 878;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 882;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (((((_la - 25)) & ~0x3f) == 0 && ((1L << (_la - 25)) & ((1L << (INVALID_STATEMENT - 25)) | (1L << (IDENT - 25)) | (1L << (MINUS - 25)))) != 0))
                        {
                            {
                                {
                                    State = 879;
                                    ident_list_item();
                                }
                            }
                            State = 884;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                        State = 885;
                        Match(RBRACKET);
                    }
                    break;
                case INVALID_STATEMENT:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 886;
                        Match(INVALID_STATEMENT);
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | bracketed_idents | empty");
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, ""));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class Ident_list_itemContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALID_STATEMENT() { return GetToken(CSSParser.INVALID_STATEMENT, 0); }
        public Ident_list_itemContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_ident_list_item; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterIdent_list_item(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitIdent_list_item(this);
        }
    }

    [RuleVersion(0)]
    public Ident_list_itemContext ident_list_item()
    {
        Ident_list_itemContext _localctx = new Ident_list_itemContext(Context, State);
        EnterRule(_localctx, 74, RULE_ident_list_item);
        int _la;
        try
        {
            State = 900;
            ErrorHandler.Sync(this);
            switch (TokenStream.LA(1))
            {
                case IDENT:
                case MINUS:
                    EnterOuterAlt(_localctx, 1);
                    {
                        State = 890;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        if (_la == MINUS)
                        {
                            {
                                State = 889;
                                Match(MINUS);
                            }
                        }

                        State = 892;
                        Match(IDENT);
                        State = 896;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                        while (_la == S)
                        {
                            {
                                {
                                    State = 893;
                                    Match(S);
                                }
                            }
                            State = 898;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                        }
                    }
                    break;
                case INVALID_STATEMENT:
                    EnterOuterAlt(_localctx, 2);
                    {
                        State = 899;
                        Match(INVALID_STATEMENT);
                    }
                    break;
                default:
                    throw new NoViableAltException(this);
            }
        }
        catch (RecognitionException re)
        {

            // log.error("Recognition exception | ident_list_item | empty");
            _localctx.AddErrorNode(this.TokenFactory.Create(INVALID_STATEMENT, ""));

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class AnyContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENT() { return GetToken(CSSParser.IDENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLASSKEYWORD() { return GetToken(CSSParser.CLASSKEYWORD, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(CSSParser.NUMBER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTAGE() { return GetToken(CSSParser.PERCENTAGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIMENSION() { return GetToken(CSSParser.DIMENSION, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public StringContext stringv()
        {
            return GetRuleContext<StringContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URI() { return GetToken(CSSParser.URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCLOSED_URI() { return GetToken(CSSParser.UNCLOSED_URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(CSSParser.HASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIRANGE() { return GetToken(CSSParser.UNIRANGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDES() { return GetToken(CSSParser.INCLUDES, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CSSParser.COMMA, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(CSSParser.GREATER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(CSSParser.LESS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION() { return GetToken(CSSParser.QUESTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(CSSParser.PERCENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUALS() { return GetToken(CSSParser.EQUALS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLASH() { return GetToken(CSSParser.SLASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION() { return GetToken(CSSParser.EXCLAMATION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CSSParser.ASTERISK, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(CSSParser.FUNCTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DASHMATCH() { return GetToken(CSSParser.DASHMATCH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CSSParser.LPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CSSParser.LBRACKET, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CSSParser.RBRACKET, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext[] any()
        {
            return GetRuleContexts<AnyContext>();
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public AnyContext any(int i)
        {
            return GetRuleContext<AnyContext>(i);
        }
        public AnyContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_any; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterAny(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitAny(this);
        }
    }

    [RuleVersion(0)]
    public AnyContext any()
    {
        AnyContext _localctx = new AnyContext(Context, State);
        EnterRule(_localctx, 76, RULE_any);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 956;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1))
                {
                    case IDENT:
                        {
                            State = 902;
                            Match(IDENT);
                        }
                        break;
                    case CLASSKEYWORD:
                        {
                            State = 903;
                            Match(CLASSKEYWORD);
                        }
                        break;
                    case NUMBER:
                        {
                            State = 904;
                            Match(NUMBER);
                        }
                        break;
                    case PERCENTAGE:
                        {
                            State = 905;
                            Match(PERCENTAGE);
                        }
                        break;
                    case DIMENSION:
                        {
                            State = 906;
                            Match(DIMENSION);
                        }
                        break;
                    case INVALID_STRING:
                    case STRING:
                    case UNCLOSED_STRING:
                        {
                            State = 907;
                            stringv();
                        }
                        break;
                    case URI:
                        {
                            State = 908;
                            Match(URI);
                        }
                        break;
                    case UNCLOSED_URI:
                        {
                            State = 909;
                            Match(UNCLOSED_URI);
                        }
                        break;
                    case HASH:
                        {
                            State = 910;
                            Match(HASH);
                        }
                        break;
                    case UNIRANGE:
                        {
                            State = 911;
                            Match(UNIRANGE);
                        }
                        break;
                    case INCLUDES:
                        {
                            State = 912;
                            Match(INCLUDES);
                        }
                        break;
                    case COLON:
                        {
                            State = 913;
                            Match(COLON);
                        }
                        break;
                    case COMMA:
                        {
                            State = 914;
                            Match(COMMA);
                        }
                        break;
                    case GREATER:
                        {
                            State = 915;
                            Match(GREATER);
                        }
                        break;
                    case LESS:
                        {
                            State = 916;
                            Match(LESS);
                        }
                        break;
                    case QUESTION:
                        {
                            State = 917;
                            Match(QUESTION);
                        }
                        break;
                    case PERCENT:
                        {
                            State = 918;
                            Match(PERCENT);
                        }
                        break;
                    case EQUALS:
                        {
                            State = 919;
                            Match(EQUALS);
                        }
                        break;
                    case SLASH:
                        {
                            State = 920;
                            Match(SLASH);
                        }
                        break;
                    case EXCLAMATION:
                        {
                            State = 921;
                            Match(EXCLAMATION);
                        }
                        break;
                    case MINUS:
                        {
                            State = 922;
                            Match(MINUS);
                        }
                        break;
                    case PLUS:
                        {
                            State = 923;
                            Match(PLUS);
                        }
                        break;
                    case ASTERISK:
                        {
                            State = 924;
                            Match(ASTERISK);
                        }
                        break;
                    case FUNCTION:
                        {
                            State = 925;
                            Match(FUNCTION);
                            State = 929;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (_la == S)
                            {
                                {
                                    {
                                        State = 926;
                                        Match(S);
                                    }
                                }
                                State = 931;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 935;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (EXCLAMATION - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                            {
                                {
                                    {
                                        State = 932;
                                        any();
                                    }
                                }
                                State = 937;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 938;
                            Match(RPAREN);
                        }
                        break;
                    case DASHMATCH:
                        {
                            State = 939;
                            Match(DASHMATCH);
                        }
                        break;
                    case LPAREN:
                        {
                            State = 940;
                            Match(LPAREN);
                            State = 944;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (EXCLAMATION - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                            {
                                {
                                    {
                                        State = 941;
                                        any();
                                    }
                                }
                                State = 946;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 947;
                            Match(RPAREN);
                        }
                        break;
                    case LBRACKET:
                        {
                            State = 948;
                            Match(LBRACKET);
                            State = 952;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            while (((((_la - 21)) & ~0x3f) == 0 && ((1L << (_la - 21)) & ((1L << (INVALID_STRING - 21)) | (1L << (IDENT - 21)) | (1L << (CLASSKEYWORD - 21)) | (1L << (STRING - 21)) | (1L << (UNCLOSED_STRING - 21)) | (1L << (HASH - 21)) | (1L << (NUMBER - 21)) | (1L << (PERCENTAGE - 21)) | (1L << (DIMENSION - 21)) | (1L << (URI - 21)) | (1L << (UNCLOSED_URI - 21)) | (1L << (UNIRANGE - 21)) | (1L << (COLON - 21)) | (1L << (COMMA - 21)) | (1L << (QUESTION - 21)) | (1L << (PERCENT - 21)) | (1L << (EQUALS - 21)) | (1L << (SLASH - 21)) | (1L << (GREATER - 21)) | (1L << (LESS - 21)) | (1L << (LPAREN - 21)) | (1L << (LBRACKET - 21)) | (1L << (EXCLAMATION - 21)) | (1L << (MINUS - 21)) | (1L << (PLUS - 21)) | (1L << (ASTERISK - 21)) | (1L << (FUNCTION - 21)) | (1L << (INCLUDES - 21)) | (1L << (DASHMATCH - 21)))) != 0))
                            {
                                {
                                    {
                                        State = 949;
                                        any();
                                    }
                                }
                                State = 954;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            }
                            State = 955;
                            Match(RBRACKET);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
                State = 961;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 958;
                            Match(S);
                        }
                    }
                    State = 963;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING any ERROR | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class NostatementContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CSSParser.RCURLY, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(CSSParser.SEMICOLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUOT() { return GetToken(CSSParser.QUOT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode APOS() { return GetToken(CSSParser.APOS, 0); }
        public NostatementContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_nostatement; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterNostatement(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitNostatement(this);
        }
    }

    [RuleVersion(0)]
    public NostatementContext nostatement()
    {
        NostatementContext _localctx = new NostatementContext(Context, State);
        EnterRule(_localctx, 78, RULE_nostatement);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 964;
                _la = TokenStream.LA(1);
                if (!(((((_la - 53)) & ~0x3f) == 0 && ((1L << (_la - 53)) & ((1L << (SEMICOLON - 53)) | (1L << (RCURLY - 53)) | (1L << (APOS - 53)) | (1L << (QUOT - 53)))) != 0)))
                {
                    ErrorHandler.RecoverInline(this);
                }
                else
                {
                    ErrorHandler.ReportMatch(this);
                    Consume();
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING nostatement ERROR | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class NopropContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLASSKEYWORD() { return GetToken(CSSParser.CLASSKEYWORD, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(CSSParser.NUMBER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTAGE() { return GetToken(CSSParser.PERCENTAGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIMENSION() { return GetToken(CSSParser.DIMENSION, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public StringContext stringv()
        {
            return GetRuleContext<StringContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CSSParser.COMMA, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HASH() { return GetToken(CSSParser.HASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URI() { return GetToken(CSSParser.URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCLOSED_URI() { return GetToken(CSSParser.UNCLOSED_URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(CSSParser.GREATER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(CSSParser.LESS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION() { return GetToken(CSSParser.QUESTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(CSSParser.PERCENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUALS() { return GetToken(CSSParser.EQUALS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLASH() { return GetToken(CSSParser.SLASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION() { return GetToken(CSSParser.EXCLAMATION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CSSParser.ASTERISK, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DASHMATCH() { return GetToken(CSSParser.DASHMATCH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDES() { return GetToken(CSSParser.INCLUDES, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING_CHAR() { return GetToken(CSSParser.STRING_CHAR, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CTRL() { return GetToken(CSSParser.CTRL, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALID_TOKEN() { return GetToken(CSSParser.INVALID_TOKEN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] S() { return GetTokens(CSSParser.S); }
        [System.Diagnostics.DebuggerNonUserCode]
        public ITerminalNode S(int i)
        {
            return GetToken(CSSParser.S, i);
        }
        public NopropContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_noprop; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterNoprop(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitNoprop(this);
        }
    }

    [RuleVersion(0)]
    public NopropContext noprop()
    {
        NopropContext _localctx = new NopropContext(Context, State);
        EnterRule(_localctx, 80, RULE_noprop);
        int _la;
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 990;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1))
                {
                    case CLASSKEYWORD:
                        {
                            State = 966;
                            Match(CLASSKEYWORD);
                        }
                        break;
                    case NUMBER:
                        {
                            State = 967;
                            Match(NUMBER);
                        }
                        break;
                    case PERCENTAGE:
                        {
                            State = 968;
                            Match(PERCENTAGE);
                        }
                        break;
                    case DIMENSION:
                        {
                            State = 969;
                            Match(DIMENSION);
                        }
                        break;
                    case INVALID_STRING:
                    case STRING:
                    case UNCLOSED_STRING:
                        {
                            State = 970;
                            stringv();
                        }
                        break;
                    case COMMA:
                        {
                            State = 971;
                            Match(COMMA);
                        }
                        break;
                    case HASH:
                        {
                            State = 972;
                            Match(HASH);
                        }
                        break;
                    case URI:
                        {
                            State = 973;
                            Match(URI);
                        }
                        break;
                    case UNCLOSED_URI:
                        {
                            State = 974;
                            Match(UNCLOSED_URI);
                        }
                        break;
                    case GREATER:
                        {
                            State = 975;
                            Match(GREATER);
                        }
                        break;
                    case LESS:
                        {
                            State = 976;
                            Match(LESS);
                        }
                        break;
                    case QUESTION:
                        {
                            State = 977;
                            Match(QUESTION);
                        }
                        break;
                    case PERCENT:
                        {
                            State = 978;
                            Match(PERCENT);
                        }
                        break;
                    case EQUALS:
                        {
                            State = 979;
                            Match(EQUALS);
                        }
                        break;
                    case SLASH:
                        {
                            State = 980;
                            Match(SLASH);
                        }
                        break;
                    case EXCLAMATION:
                        {
                            State = 981;
                            Match(EXCLAMATION);
                        }
                        break;
                    case PLUS:
                        {
                            State = 982;
                            Match(PLUS);
                        }
                        break;
                    case ASTERISK:
                        {
                            State = 983;
                            Match(ASTERISK);
                        }
                        break;
                    case DASHMATCH:
                        {
                            State = 984;
                            Match(DASHMATCH);
                        }
                        break;
                    case INCLUDES:
                        {
                            State = 985;
                            Match(INCLUDES);
                        }
                        break;
                    case COLON:
                        {
                            State = 986;
                            Match(COLON);
                        }
                        break;
                    case STRING_CHAR:
                        {
                            State = 987;
                            Match(STRING_CHAR);
                        }
                        break;
                    case CTRL:
                        {
                            State = 988;
                            Match(CTRL);
                        }
                        break;
                    case INVALID_TOKEN:
                        {
                            State = 989;
                            Match(INVALID_TOKEN);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
                State = 995;
                ErrorHandler.Sync(this);
                _la = TokenStream.LA(1);
                while (_la == S)
                {
                    {
                        {
                            State = 992;
                            Match(S);
                        }
                    }
                    State = 997;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING noprop ERROR | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class NoruleContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(CSSParser.NUMBER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTAGE() { return GetToken(CSSParser.PERCENTAGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIMENSION() { return GetToken(CSSParser.DIMENSION, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public StringContext stringv()
        {
            return GetRuleContext<StringContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URI() { return GetToken(CSSParser.URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCLOSED_URI() { return GetToken(CSSParser.UNCLOSED_URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIRANGE() { return GetToken(CSSParser.UNIRANGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDES() { return GetToken(CSSParser.INCLUDES, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CSSParser.COMMA, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(CSSParser.GREATER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(CSSParser.LESS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION() { return GetToken(CSSParser.QUESTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(CSSParser.PERCENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUALS() { return GetToken(CSSParser.EQUALS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLASH() { return GetToken(CSSParser.SLASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION() { return GetToken(CSSParser.EXCLAMATION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DASHMATCH() { return GetToken(CSSParser.DASHMATCH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CTRL() { return GetToken(CSSParser.CTRL, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POUND() { return GetToken(CSSParser.POUND, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HAT() { return GetToken(CSSParser.HAT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMPERSAND() { return GetToken(CSSParser.AMPERSAND, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALID_TOKEN() { return GetToken(CSSParser.INVALID_TOKEN, 0); }
        public NoruleContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_norule; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterNorule(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitNorule(this);
        }
    }

    [RuleVersion(0)]
    public NoruleContext norule()
    {
        NoruleContext _localctx = new NoruleContext(Context, State);
        EnterRule(_localctx, 82, RULE_norule);
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 1023;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1))
                {
                    case NUMBER:
                        {
                            State = 998;
                            Match(NUMBER);
                        }
                        break;
                    case PERCENTAGE:
                        {
                            State = 999;
                            Match(PERCENTAGE);
                        }
                        break;
                    case DIMENSION:
                        {
                            State = 1000;
                            Match(DIMENSION);
                        }
                        break;
                    case INVALID_STRING:
                    case STRING:
                    case UNCLOSED_STRING:
                        {
                            State = 1001;
                            stringv();
                        }
                        break;
                    case URI:
                        {
                            State = 1002;
                            Match(URI);
                        }
                        break;
                    case UNCLOSED_URI:
                        {
                            State = 1003;
                            Match(UNCLOSED_URI);
                        }
                        break;
                    case UNIRANGE:
                        {
                            State = 1004;
                            Match(UNIRANGE);
                        }
                        break;
                    case INCLUDES:
                        {
                            State = 1005;
                            Match(INCLUDES);
                        }
                        break;
                    case COMMA:
                        {
                            State = 1006;
                            Match(COMMA);
                        }
                        break;
                    case GREATER:
                        {
                            State = 1007;
                            Match(GREATER);
                        }
                        break;
                    case LESS:
                        {
                            State = 1008;
                            Match(LESS);
                        }
                        break;
                    case QUESTION:
                        {
                            State = 1009;
                            Match(QUESTION);
                        }
                        break;
                    case PERCENT:
                        {
                            State = 1010;
                            Match(PERCENT);
                        }
                        break;
                    case EQUALS:
                        {
                            State = 1011;
                            Match(EQUALS);
                        }
                        break;
                    case SLASH:
                        {
                            State = 1012;
                            Match(SLASH);
                        }
                        break;
                    case EXCLAMATION:
                        {
                            State = 1013;
                            Match(EXCLAMATION);
                        }
                        break;
                    case MINUS:
                        {
                            State = 1014;
                            Match(MINUS);
                        }
                        break;
                    case PLUS:
                        {
                            State = 1015;
                            Match(PLUS);
                        }
                        break;
                    case DASHMATCH:
                        {
                            State = 1016;
                            Match(DASHMATCH);
                        }
                        break;
                    case RPAREN:
                        {
                            State = 1017;
                            Match(RPAREN);
                        }
                        break;
                    case CTRL:
                        {
                            State = 1018;
                            Match(CTRL);
                        }
                        break;
                    case POUND:
                        {
                            State = 1019;
                            Match(POUND);
                        }
                        break;
                    case HAT:
                        {
                            State = 1020;
                            Match(HAT);
                        }
                        break;
                    case AMPERSAND:
                        {
                            State = 1021;
                            Match(AMPERSAND);
                        }
                        break;
                    case INVALID_TOKEN:
                        {
                            State = 1022;
                            Match(INVALID_TOKEN);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING norule ERROR | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    public partial class NomediaqueryContext : ParserRuleContext
    {
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(CSSParser.NUMBER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENTAGE() { return GetToken(CSSParser.PERCENTAGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIMENSION() { return GetToken(CSSParser.DIMENSION, 0); }
        [System.Diagnostics.DebuggerNonUserCode]
        public StringContext stringv()
        {
            return GetRuleContext<StringContext>(0);
        }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URI() { return GetToken(CSSParser.URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNCLOSED_URI() { return GetToken(CSSParser.UNCLOSED_URI, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIRANGE() { return GetToken(CSSParser.UNIRANGE, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INCLUDES() { return GetToken(CSSParser.INCLUDES, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GREATER() { return GetToken(CSSParser.GREATER, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LESS() { return GetToken(CSSParser.LESS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION() { return GetToken(CSSParser.QUESTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(CSSParser.PERCENT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQUALS() { return GetToken(CSSParser.EQUALS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SLASH() { return GetToken(CSSParser.SLASH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION() { return GetToken(CSSParser.EXCLAMATION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CSSParser.MINUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CSSParser.PLUS, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DASHMATCH() { return GetToken(CSSParser.DASHMATCH, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CSSParser.RPAREN, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CTRL() { return GetToken(CSSParser.CTRL, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CSSParser.COLON, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASTERISK() { return GetToken(CSSParser.ASTERISK, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(CSSParser.FUNCTION, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POUND() { return GetToken(CSSParser.POUND, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HAT() { return GetToken(CSSParser.HAT, 0); }
        [System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMPERSAND() { return GetToken(CSSParser.AMPERSAND, 0); }
        public NomediaqueryContext(ParserRuleContext parent, int invokingState)
            : base(parent, invokingState)
        {
        }
        public override int RuleIndex { get { return RULE_nomediaquery; } }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void EnterRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.EnterNomediaquery(this);
        }
        [System.Diagnostics.DebuggerNonUserCode]
        public override void ExitRule(IParseTreeListener listener)
        {
            ICSSParserListener typedListener = listener as ICSSParserListener;
            if (typedListener != null) typedListener.ExitNomediaquery(this);
        }
    }

    [RuleVersion(0)]
    public NomediaqueryContext nomediaquery()
    {
        NomediaqueryContext _localctx = new NomediaqueryContext(Context, State);
        EnterRule(_localctx, 84, RULE_nomediaquery);
        try
        {
            EnterOuterAlt(_localctx, 1);
            {
                State = 1051;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1))
                {
                    case NUMBER:
                        {
                            State = 1025;
                            Match(NUMBER);
                        }
                        break;
                    case PERCENTAGE:
                        {
                            State = 1026;
                            Match(PERCENTAGE);
                        }
                        break;
                    case DIMENSION:
                        {
                            State = 1027;
                            Match(DIMENSION);
                        }
                        break;
                    case INVALID_STRING:
                    case STRING:
                    case UNCLOSED_STRING:
                        {
                            State = 1028;
                            stringv();
                        }
                        break;
                    case URI:
                        {
                            State = 1029;
                            Match(URI);
                        }
                        break;
                    case UNCLOSED_URI:
                        {
                            State = 1030;
                            Match(UNCLOSED_URI);
                        }
                        break;
                    case UNIRANGE:
                        {
                            State = 1031;
                            Match(UNIRANGE);
                        }
                        break;
                    case INCLUDES:
                        {
                            State = 1032;
                            Match(INCLUDES);
                        }
                        break;
                    case GREATER:
                        {
                            State = 1033;
                            Match(GREATER);
                        }
                        break;
                    case LESS:
                        {
                            State = 1034;
                            Match(LESS);
                        }
                        break;
                    case QUESTION:
                        {
                            State = 1035;
                            Match(QUESTION);
                        }
                        break;
                    case PERCENT:
                        {
                            State = 1036;
                            Match(PERCENT);
                        }
                        break;
                    case EQUALS:
                        {
                            State = 1037;
                            Match(EQUALS);
                        }
                        break;
                    case SLASH:
                        {
                            State = 1038;
                            Match(SLASH);
                        }
                        break;
                    case EXCLAMATION:
                        {
                            State = 1039;
                            Match(EXCLAMATION);
                        }
                        break;
                    case MINUS:
                        {
                            State = 1040;
                            Match(MINUS);
                        }
                        break;
                    case PLUS:
                        {
                            State = 1041;
                            Match(PLUS);
                        }
                        break;
                    case DASHMATCH:
                        {
                            State = 1042;
                            Match(DASHMATCH);
                        }
                        break;
                    case RPAREN:
                        {
                            State = 1043;
                            Match(RPAREN);
                        }
                        break;
                    case CTRL:
                        {
                            State = 1044;
                            Match(CTRL);
                        }
                        break;
                    case COLON:
                        {
                            State = 1045;
                            Match(COLON);
                        }
                        break;
                    case ASTERISK:
                        {
                            State = 1046;
                            Match(ASTERISK);
                        }
                        break;
                    case FUNCTION:
                        {
                            State = 1047;
                            Match(FUNCTION);
                        }
                        break;
                    case POUND:
                        {
                            State = 1048;
                            Match(POUND);
                        }
                        break;
                    case HAT:
                        {
                            State = 1049;
                            Match(HAT);
                        }
                        break;
                    case AMPERSAND:
                        {
                            State = 1050;
                            Match(AMPERSAND);
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            }
        }
        catch (RecognitionException re)
        {

            // log.error("PARSING nomediaquery ERROR | should be empty");

        }
        finally
        {
            ExitRule();
        }
        return _localctx;
    }

    private static char[] _serializedATN = {
        '\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786',
        '\x5964', '\x3', '^', '\x420', '\x4', '\x2', '\t', '\x2', '\x4', '\x3',
        '\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4',
        '\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b',
        '\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v',
        '\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t',
        '\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4',
        '\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t',
        '\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4',
        '\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t',
        '\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4',
        '\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t',
        '\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4',
        ' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4',
        '#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&',
        '\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')',
        '\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t',
        ',', '\x3', '\x2', '\a', '\x2', 'Z', '\n', '\x2', '\f', '\x2', '\xE',
        '\x2', ']', '\v', '\x2', '\x3', '\x2', '\x3', '\x2', '\x6', '\x2', '\x61',
        '\n', '\x2', '\r', '\x2', '\xE', '\x2', '\x62', '\x5', '\x2', '\x65',
        '\n', '\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3',
        '\x3', '\a', '\x3', 'l', '\n', '\x3', '\f', '\x3', '\xE', '\x3', 'o',
        '\v', '\x3', '\x3', '\x4', '\x3', '\x4', '\x5', '\x4', 's', '\n', '\x4',
        '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\a', '\x5', 'x', '\n', '\x5',
        '\f', '\x5', '\xE', '\x5', '{', '\v', '\x5', '\x3', '\x5', '\x3', '\x5',
        '\a', '\x5', '\x7F', '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\x82', '\v',
        '\x5', '\x3', '\x5', '\x5', '\x5', '\x85', '\n', '\x5', '\x3', '\x5',
        '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\a', '\x5', '\x8C',
        '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\x8F', '\v', '\x5', '\x3', '\x5',
        '\x3', '\x5', '\a', '\x5', '\x93', '\n', '\x5', '\f', '\x5', '\xE', '\x5',
        '\x96', '\v', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3',
        '\x5', '\x3', '\x5', '\a', '\x5', '\x9D', '\n', '\x5', '\f', '\x5', '\xE',
        '\x5', '\xA0', '\v', '\x5', '\x3', '\x5', '\x3', '\x5', '\a', '\x5', '\xA4',
        '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\xA7', '\v', '\x5', '\x3', '\x5',
        '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\a', '\x5', '\xAE',
        '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\xB1', '\v', '\x5', '\x3', '\x5',
        '\x5', '\x5', '\xB4', '\n', '\x5', '\x3', '\x5', '\x3', '\x5', '\a', '\x5',
        '\xB8', '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\xBB', '\v', '\x5', '\x3',
        '\x5', '\x3', '\x5', '\a', '\x5', '\xBF', '\n', '\x5', '\f', '\x5', '\xE',
        '\x5', '\xC2', '\v', '\x5', '\a', '\x5', '\xC4', '\n', '\x5', '\f', '\x5',
        '\xE', '\x5', '\xC7', '\v', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3',
        '\x5', '\a', '\x5', '\xCC', '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\xCF',
        '\v', '\x5', '\x3', '\x5', '\x3', '\x5', '\a', '\x5', '\xD3', '\n', '\x5',
        '\f', '\x5', '\xE', '\x5', '\xD6', '\v', '\x5', '\x3', '\x5', '\x3', '\x5',
        '\a', '\x5', '\xDA', '\n', '\x5', '\f', '\x5', '\xE', '\x5', '\xDD', '\v',
        '\x5', '\x3', '\x5', '\x3', '\x5', '\a', '\x5', '\xE1', '\n', '\x5', '\f',
        '\x5', '\xE', '\x5', '\xE4', '\v', '\x5', '\a', '\x5', '\xE6', '\n', '\x5',
        '\f', '\x5', '\xE', '\x5', '\xE9', '\v', '\x5', '\x3', '\x5', '\x3', '\x5',
        '\x3', '\x5', '\x5', '\x5', '\xEE', '\n', '\x5', '\x3', '\x6', '\x3',
        '\x6', '\x3', '\a', '\x3', '\a', '\a', '\a', '\xF4', '\n', '\a', '\f',
        '\a', '\xE', '\a', '\xF7', '\v', '\a', '\x3', '\a', '\x5', '\a', '\xFA',
        '\n', '\a', '\x3', '\a', '\x5', '\a', '\xFD', '\n', '\a', '\x3', '\a',
        '\a', '\a', '\x100', '\n', '\a', '\f', '\a', '\xE', '\a', '\x103', '\v',
        '\a', '\x3', '\a', '\x3', '\a', '\a', '\a', '\x107', '\n', '\a', '\f',
        '\a', '\xE', '\a', '\x10A', '\v', '\a', '\x3', '\a', '\x3', '\a', '\a',
        '\a', '\x10E', '\n', '\a', '\f', '\a', '\xE', '\a', '\x111', '\v', '\a',
        '\x3', '\a', '\x3', '\a', '\x3', '\b', '\x3', '\b', '\a', '\b', '\x117',
        '\n', '\b', '\f', '\b', '\xE', '\b', '\x11A', '\v', '\b', '\x3', '\b',
        '\x3', '\b', '\a', '\b', '\x11E', '\n', '\b', '\f', '\b', '\xE', '\b',
        '\x121', '\v', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\a', '\b',
        '\x126', '\n', '\b', '\f', '\b', '\xE', '\b', '\x129', '\v', '\b', '\x3',
        '\t', '\x3', '\t', '\a', '\t', '\x12D', '\n', '\t', '\f', '\t', '\xE',
        '\t', '\x130', '\v', '\t', '\x3', '\t', '\x3', '\t', '\a', '\t', '\x134',
        '\n', '\t', '\f', '\t', '\xE', '\t', '\x137', '\v', '\t', '\x3', '\t',
        '\x3', '\t', '\a', '\t', '\x13B', '\n', '\t', '\f', '\t', '\xE', '\t',
        '\x13E', '\v', '\t', '\a', '\t', '\x140', '\n', '\t', '\f', '\t', '\xE',
        '\t', '\x143', '\v', '\t', '\x5', '\t', '\x145', '\n', '\t', '\x3', '\t',
        '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\n', '\x3', '\n', '\x3',
        '\n', '\a', '\n', '\x14E', '\n', '\n', '\f', '\n', '\xE', '\n', '\x151',
        '\v', '\n', '\x3', '\n', '\a', '\n', '\x154', '\n', '\n', '\f', '\n',
        '\xE', '\n', '\x157', '\v', '\n', '\x3', '\v', '\x3', '\v', '\a', '\v',
        '\x15B', '\n', '\v', '\f', '\v', '\xE', '\v', '\x15E', '\v', '\v', '\x6',
        '\v', '\x160', '\n', '\v', '\r', '\v', '\xE', '\v', '\x161', '\x3', '\f',
        '\x3', '\f', '\x5', '\f', '\x166', '\n', '\f', '\x3', '\f', '\x5', '\f',
        '\x169', '\n', '\f', '\x3', '\r', '\x3', '\r', '\a', '\r', '\x16D', '\n',
        '\r', '\f', '\r', '\xE', '\r', '\x170', '\v', '\r', '\x3', '\r', '\x3',
        '\r', '\a', '\r', '\x174', '\n', '\r', '\f', '\r', '\xE', '\r', '\x177',
        '\v', '\r', '\x3', '\r', '\x3', '\r', '\a', '\r', '\x17B', '\n', '\r',
        '\f', '\r', '\xE', '\r', '\x17E', '\v', '\r', '\x3', '\r', '\x5', '\r',
        '\x181', '\n', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\xE', '\x3', '\xE',
        '\x5', '\xE', '\x187', '\n', '\xE', '\x3', '\xF', '\x3', '\xF', '\x5',
        '\xF', '\x18B', '\n', '\xF', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10',
        '\a', '\x10', '\x190', '\n', '\x10', '\f', '\x10', '\xE', '\x10', '\x193',
        '\v', '\x10', '\x3', '\x10', '\a', '\x10', '\x196', '\n', '\x10', '\f',
        '\x10', '\xE', '\x10', '\x199', '\v', '\x10', '\x3', '\x10', '\x3', '\x10',
        '\a', '\x10', '\x19D', '\n', '\x10', '\f', '\x10', '\xE', '\x10', '\x1A0',
        '\v', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\x3', '\x11',
        '\x3', '\x11', '\a', '\x11', '\x1A7', '\n', '\x11', '\f', '\x11', '\xE',
        '\x11', '\x1AA', '\v', '\x11', '\x3', '\x11', '\x3', '\x11', '\a', '\x11',
        '\x1AE', '\n', '\x11', '\f', '\x11', '\xE', '\x11', '\x1B1', '\v', '\x11',
        '\x5', '\x11', '\x1B3', '\n', '\x11', '\x3', '\x12', '\x3', '\x12', '\a',
        '\x12', '\x1B7', '\n', '\x12', '\f', '\x12', '\xE', '\x12', '\x1BA', '\v',
        '\x12', '\x3', '\x12', '\a', '\x12', '\x1BD', '\n', '\x12', '\f', '\x12',
        '\xE', '\x12', '\x1C0', '\v', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3',
        '\x12', '\a', '\x12', '\x1C5', '\n', '\x12', '\f', '\x12', '\xE', '\x12',
        '\x1C8', '\v', '\x12', '\x3', '\x12', '\a', '\x12', '\x1CB', '\n', '\x12',
        '\f', '\x12', '\xE', '\x12', '\x1CE', '\v', '\x12', '\x3', '\x12', '\x5',
        '\x12', '\x1D1', '\n', '\x12', '\x3', '\x13', '\x3', '\x13', '\a', '\x13',
        '\x1D5', '\n', '\x13', '\f', '\x13', '\xE', '\x13', '\x1D8', '\v', '\x13',
        '\x3', '\x13', '\x3', '\x13', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14',
        '\a', '\x14', '\x1DF', '\n', '\x14', '\f', '\x14', '\xE', '\x14', '\x1E2',
        '\v', '\x14', '\x3', '\x14', '\a', '\x14', '\x1E5', '\n', '\x14', '\f',
        '\x14', '\xE', '\x14', '\x1E8', '\v', '\x14', '\x5', '\x14', '\x1EA',
        '\n', '\x14', '\x3', '\x14', '\x3', '\x14', '\a', '\x14', '\x1EE', '\n',
        '\x14', '\f', '\x14', '\xE', '\x14', '\x1F1', '\v', '\x14', '\x3', '\x14',
        '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14',
        '\x5', '\x14', '\x1F9', '\n', '\x14', '\x3', '\x15', '\x5', '\x15', '\x1FC',
        '\n', '\x15', '\x3', '\x15', '\x3', '\x15', '\a', '\x15', '\x200', '\n',
        '\x15', '\f', '\x15', '\xE', '\x15', '\x203', '\v', '\x15', '\x3', '\x15',
        '\x5', '\x15', '\x206', '\n', '\x15', '\a', '\x15', '\x208', '\n', '\x15',
        '\f', '\x15', '\xE', '\x15', '\x20B', '\v', '\x15', '\x3', '\x16', '\x3',
        '\x16', '\x3', '\x16', '\a', '\x16', '\x210', '\n', '\x16', '\f', '\x16',
        '\xE', '\x16', '\x213', '\v', '\x16', '\x3', '\x16', '\x5', '\x16', '\x216',
        '\n', '\x16', '\x3', '\x16', '\x5', '\x16', '\x219', '\n', '\x16', '\x3',
        '\x16', '\x3', '\x16', '\a', '\x16', '\x21D', '\n', '\x16', '\f', '\x16',
        '\xE', '\x16', '\x220', '\v', '\x16', '\x5', '\x16', '\x222', '\n', '\x16',
        '\x3', '\x17', '\x3', '\x17', '\a', '\x17', '\x226', '\n', '\x17', '\f',
        '\x17', '\xE', '\x17', '\x229', '\v', '\x17', '\x3', '\x17', '\x3', '\x17',
        '\a', '\x17', '\x22D', '\n', '\x17', '\f', '\x17', '\xE', '\x17', '\x230',
        '\v', '\x17', '\x3', '\x18', '\x5', '\x18', '\x233', '\n', '\x18', '\x3',
        '\x18', '\x3', '\x18', '\a', '\x18', '\x237', '\n', '\x18', '\f', '\x18',
        '\xE', '\x18', '\x23A', '\v', '\x18', '\x3', '\x19', '\x6', '\x19', '\x23D',
        '\n', '\x19', '\r', '\x19', '\xE', '\x19', '\x23E', '\x3', '\x1A', '\x3',
        '\x1A', '\x3', '\x1A', '\a', '\x1A', '\x244', '\n', '\x1A', '\f', '\x1A',
        '\xE', '\x1A', '\x247', '\v', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3',
        '\x1A', '\a', '\x1A', '\x24C', '\n', '\x1A', '\f', '\x1A', '\xE', '\x1A',
        '\x24F', '\v', '\x1A', '\a', '\x1A', '\x251', '\n', '\x1A', '\f', '\x1A',
        '\xE', '\x1A', '\x254', '\v', '\x1A', '\x3', '\x1A', '\x3', '\x1A', '\x3',
        '\x1A', '\a', '\x1A', '\x259', '\n', '\x1A', '\f', '\x1A', '\xE', '\x1A',
        '\x25C', '\v', '\x1A', '\x5', '\x1A', '\x25E', '\n', '\x1A', '\x3', '\x1B',
        '\x3', '\x1B', '\a', '\x1B', '\x262', '\n', '\x1B', '\f', '\x1B', '\xE',
        '\x1B', '\x265', '\v', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1B',
        '\a', '\x1B', '\x26A', '\n', '\x1B', '\f', '\x1B', '\xE', '\x1B', '\x26D',
        '\v', '\x1B', '\a', '\x1B', '\x26F', '\n', '\x1B', '\f', '\x1B', '\xE',
        '\x1B', '\x272', '\v', '\x1B', '\x3', '\x1B', '\x3', '\x1B', '\x3', '\x1B',
        '\a', '\x1B', '\x277', '\n', '\x1B', '\f', '\x1B', '\xE', '\x1B', '\x27A',
        '\v', '\x1B', '\x3', '\x1B', '\x5', '\x1B', '\x27D', '\n', '\x1B', '\x3',
        '\x1B', '\x5', '\x1B', '\x280', '\n', '\x1B', '\x3', '\x1C', '\x5', '\x1C',
        '\x283', '\n', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x5', '\x1C', '\x287',
        '\n', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x5', '\x1C', '\x28B', '\n',
        '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x5', '\x1C', '\x28F', '\n', '\x1C',
        '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C',
        '\x3', '\x1C', '\x5', '\x1C', '\x297', '\n', '\x1C', '\x3', '\x1C', '\x3',
        '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3',
        '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3',
        '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3',
        '\x1C', '\a', '\x1C', '\x2AA', '\n', '\x1C', '\f', '\x1C', '\xE', '\x1C',
        '\x2AD', '\v', '\x1C', '\x3', '\x1C', '\x5', '\x1C', '\x2B0', '\n', '\x1C',
        '\x3', '\x1C', '\a', '\x1C', '\x2B3', '\n', '\x1C', '\f', '\x1C', '\xE',
        '\x1C', '\x2B6', '\v', '\x1C', '\x3', '\x1D', '\x6', '\x1D', '\x2B9',
        '\n', '\x1D', '\r', '\x1D', '\xE', '\x1D', '\x2BA', '\x3', '\x1E', '\x3',
        '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3',
        '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3',
        '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3',
        '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3',
        '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x5', '\x1E', '\x2D5', '\n', '\x1E',
        '\x3', '\x1E', '\a', '\x1E', '\x2D8', '\n', '\x1E', '\f', '\x1E', '\xE',
        '\x1E', '\x2DB', '\v', '\x1E', '\x3', '\x1F', '\x3', '\x1F', '\x3', '\x1F',
        '\x3', '\x1F', '\a', '\x1F', '\x2E1', '\n', '\x1F', '\f', '\x1F', '\xE',
        '\x1F', '\x2E4', '\v', '\x1F', '\x3', ' ', '\x3', ' ', '\a', ' ', '\x2E8',
        '\n', ' ', '\f', ' ', '\xE', ' ', '\x2EB', '\v', ' ', '\x3', ' ', '\x3',
        ' ', '\a', ' ', '\x2EF', '\n', ' ', '\f', ' ', '\xE', ' ', '\x2F2', '\v',
        ' ', '\x3', ' ', '\x3', ' ', '\a', ' ', '\x2F6', '\n', ' ', '\f', ' ',
        '\xE', ' ', '\x2F9', '\v', ' ', '\x3', ' ', '\x5', ' ', '\x2FC', '\n',
        ' ', '\x3', '!', '\x3', '!', '\a', '!', '\x300', '\n', '!', '\f', '!',
        '\xE', '!', '\x303', '\v', '!', '\x3', '!', '\a', '!', '\x306', '\n',
        '!', '\f', '!', '\xE', '!', '\x309', '\v', '!', '\x3', '!', '\x6', '!',
        '\x30C', '\n', '!', '\r', '!', '\xE', '!', '\x30D', '\x3', '!', '\a',
        '!', '\x311', '\n', '!', '\f', '!', '\xE', '!', '\x314', '\v', '!', '\x5',
        '!', '\x316', '\n', '!', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3',
        '\"', '\a', '\"', '\x31C', '\n', '\"', '\f', '\"', '\xE', '\"', '\x31F',
        '\v', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3', '\"', '\x3',
        '\"', '\x5', '\"', '\x326', '\n', '\"', '\x3', '#', '\x3', '#', '\a',
        '#', '\x32A', '\n', '#', '\f', '#', '\xE', '#', '\x32D', '\v', '#', '\x3',
        '#', '\x3', '#', '\a', '#', '\x331', '\n', '#', '\f', '#', '\xE', '#',
        '\x334', '\v', '#', '\x3', '#', '\x3', '#', '\x5', '#', '\x338', '\n',
        '#', '\x3', '#', '\a', '#', '\x33B', '\n', '#', '\f', '#', '\xE', '#',
        '\x33E', '\v', '#', '\x5', '#', '\x340', '\n', '#', '\x3', '$', '\x3',
        '$', '\x5', '$', '\x344', '\n', '$', '\x3', '$', '\x5', '$', '\x347',
        '\n', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\a', '$', '\x34C', '\n',
        '$', '\f', '$', '\xE', '$', '\x34F', '\v', '$', '\x3', '$', '\x5', '$',
        '\x352', '\n', '$', '\x3', '$', '\x3', '$', '\x5', '$', '\x356', '\n',
        '$', '\x3', '$', '\x3', '$', '\x5', '$', '\x35A', '\n', '$', '\x3', '$',
        '\x3', '$', '\x5', '$', '\x35E', '\n', '$', '\x3', '$', '\a', '$', '\x361',
        '\n', '$', '\f', '$', '\xE', '$', '\x364', '\v', '$', '\x3', '$', '\x5',
        '$', '\x367', '\n', '$', '\x3', '%', '\x3', '%', '\x3', '&', '\x3', '&',
        '\a', '&', '\x36D', '\n', '&', '\f', '&', '\xE', '&', '\x370', '\v', '&',
        '\x3', '&', '\a', '&', '\x373', '\n', '&', '\f', '&', '\xE', '&', '\x376',
        '\v', '&', '\x3', '&', '\x3', '&', '\x5', '&', '\x37A', '\n', '&', '\x3',
        '\'', '\x5', '\'', '\x37D', '\n', '\'', '\x3', '\'', '\x3', '\'', '\a',
        '\'', '\x381', '\n', '\'', '\f', '\'', '\xE', '\'', '\x384', '\v', '\'',
        '\x3', '\'', '\x5', '\'', '\x387', '\n', '\'', '\x3', '(', '\x3', '(',
        '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(',
        '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(',
        '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(',
        '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\a', '(',
        '\x3A2', '\n', '(', '\f', '(', '\xE', '(', '\x3A5', '\v', '(', '\x3',
        '(', '\a', '(', '\x3A8', '\n', '(', '\f', '(', '\xE', '(', '\x3AB', '\v',
        '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\a', '(', '\x3B1',
        '\n', '(', '\f', '(', '\xE', '(', '\x3B4', '\v', '(', '\x3', '(', '\x3',
        '(', '\x3', '(', '\a', '(', '\x3B9', '\n', '(', '\f', '(', '\xE', '(',
        '\x3BC', '\v', '(', '\x3', '(', '\x5', '(', '\x3BF', '\n', '(', '\x3',
        '(', '\a', '(', '\x3C2', '\n', '(', '\f', '(', '\xE', '(', '\x3C5', '\v',
        '(', '\x3', ')', '\x3', ')', '\x3', '*', '\x3', '*', '\x3', '*', '\x3',
        '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3',
        '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3',
        '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3', '*', '\x3',
        '*', '\x3', '*', '\x3', '*', '\x5', '*', '\x3E1', '\n', '*', '\x3', '*',
        '\a', '*', '\x3E4', '\n', '*', '\f', '*', '\xE', '*', '\x3E7', '\v', '*',
        '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+',
        '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+',
        '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+',
        '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+',
        '\x3', '+', '\x5', '+', '\x402', '\n', '+', '\x3', ',', '\x3', ',', '\x3',
        ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3',
        ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3',
        ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3',
        ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', ',', '\x5',
        ',', '\x41E', '\n', ',', '\x3', ',', '\x2', '\x2', '-', '\x2', '\x4',
        '\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', '\x14', '\x16', '\x18',
        '\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '(', '*', ',', '.', '\x30',
        '\x32', '\x34', '\x36', '\x38', ':', '<', '>', '@', '\x42', '\x44', '\x46',
        'H', 'J', 'L', 'N', 'P', 'R', 'T', 'V', '\x2', '\b', '\x4', '\x2', '+',
        ',', '\x32', '\x33', '\x3', '\x2', 'J', 'K', '\x4', '\x2', ' ', ' ', 'L',
        'L', '\x4', '\x2', '<', '<', 'U', 'Y', '\x4', '\x2', '\x17', '\x17', '+',
        ',', '\x4', '\x2', '\x37', '\x37', '\x41', '\x43', '\x2', '\x522', '\x2',
        '[', '\x3', '\x2', '\x2', '\x2', '\x4', 'm', '\x3', '\x2', '\x2', '\x2',
        '\x6', 'r', '\x3', '\x2', '\x2', '\x2', '\b', '\xED', '\x3', '\x2', '\x2',
        '\x2', '\n', '\xEF', '\x3', '\x2', '\x2', '\x2', '\f', '\xF1', '\x3',
        '\x2', '\x2', '\x2', '\xE', '\x114', '\x3', '\x2', '\x2', '\x2', '\x10',
        '\x144', '\x3', '\x2', '\x2', '\x2', '\x12', '\x14A', '\x3', '\x2', '\x2',
        '\x2', '\x14', '\x15F', '\x3', '\x2', '\x2', '\x2', '\x16', '\x168', '\x3',
        '\x2', '\x2', '\x2', '\x18', '\x16A', '\x3', '\x2', '\x2', '\x2', '\x1A',
        '\x186', '\x3', '\x2', '\x2', '\x2', '\x1C', '\x18A', '\x3', '\x2', '\x2',
        '\x2', '\x1E', '\x18C', '\x3', '\x2', '\x2', '\x2', ' ', '\x1B2', '\x3',
        '\x2', '\x2', '\x2', '\"', '\x1D0', '\x3', '\x2', '\x2', '\x2', '$', '\x1D2',
        '\x3', '\x2', '\x2', '\x2', '&', '\x1F8', '\x3', '\x2', '\x2', '\x2',
        '(', '\x1FB', '\x3', '\x2', '\x2', '\x2', '*', '\x221', '\x3', '\x2',
        '\x2', '\x2', ',', '\x223', '\x3', '\x2', '\x2', '\x2', '.', '\x232',
        '\x3', '\x2', '\x2', '\x2', '\x30', '\x23C', '\x3', '\x2', '\x2', '\x2',
        '\x32', '\x25D', '\x3', '\x2', '\x2', '\x2', '\x34', '\x27F', '\x3', '\x2',
        '\x2', '\x2', '\x36', '\x2AF', '\x3', '\x2', '\x2', '\x2', '\x38', '\x2B8',
        '\x3', '\x2', '\x2', '\x2', ':', '\x2D4', '\x3', '\x2', '\x2', '\x2',
        '<', '\x2DC', '\x3', '\x2', '\x2', '\x2', '>', '\x2FB', '\x3', '\x2',
        '\x2', '\x2', '@', '\x315', '\x3', '\x2', '\x2', '\x2', '\x42', '\x325',
        '\x3', '\x2', '\x2', '\x2', '\x44', '\x327', '\x3', '\x2', '\x2', '\x2',
        '\x46', '\x341', '\x3', '\x2', '\x2', '\x2', 'H', '\x368', '\x3', '\x2',
        '\x2', '\x2', 'J', '\x379', '\x3', '\x2', '\x2', '\x2', 'L', '\x386',
        '\x3', '\x2', '\x2', '\x2', 'N', '\x3BE', '\x3', '\x2', '\x2', '\x2',
        'P', '\x3C6', '\x3', '\x2', '\x2', '\x2', 'R', '\x3E0', '\x3', '\x2',
        '\x2', '\x2', 'T', '\x401', '\x3', '\x2', '\x2', '\x2', 'V', '\x41D',
        '\x3', '\x2', '\x2', '\x2', 'X', 'Z', '\a', 'P', '\x2', '\x2', 'Y', 'X',
        '\x3', '\x2', '\x2', '\x2', 'Z', ']', '\x3', '\x2', '\x2', '\x2', '[',
        'Y', '\x3', '\x2', '\x2', '\x2', '[', '\\', '\x3', '\x2', '\x2', '\x2',
        '\\', '\x64', '\x3', '\x2', '\x2', '\x2', ']', '[', '\x3', '\x2', '\x2',
        '\x2', '^', '\x65', '\x5', '(', '\x15', '\x2', '_', '\x61', '\x5', '\x10',
        '\t', '\x2', '`', '_', '\x3', '\x2', '\x2', '\x2', '\x61', '\x62', '\x3',
        '\x2', '\x2', '\x2', '\x62', '`', '\x3', '\x2', '\x2', '\x2', '\x62',
        '\x63', '\x3', '\x2', '\x2', '\x2', '\x63', '\x65', '\x3', '\x2', '\x2',
        '\x2', '\x64', '^', '\x3', '\x2', '\x2', '\x2', '\x64', '`', '\x3', '\x2',
        '\x2', '\x2', '\x65', '\x3', '\x3', '\x2', '\x2', '\x2', '\x66', 'l',
        '\a', '\x35', '\x2', '\x2', 'g', 'l', '\a', '\x36', '\x2', '\x2', 'h',
        'l', '\a', 'P', '\x2', '\x2', 'i', 'l', '\x5', 'P', ')', '\x2', 'j', 'l',
        '\x5', '\x6', '\x4', '\x2', 'k', '\x66', '\x3', '\x2', '\x2', '\x2', 'k',
        'g', '\x3', '\x2', '\x2', '\x2', 'k', 'h', '\x3', '\x2', '\x2', '\x2',
        'k', 'i', '\x3', '\x2', '\x2', '\x2', 'k', 'j', '\x3', '\x2', '\x2', '\x2',
        'l', 'o', '\x3', '\x2', '\x2', '\x2', 'm', 'k', '\x3', '\x2', '\x2', '\x2',
        'm', 'n', '\x3', '\x2', '\x2', '\x2', 'n', '\x5', '\x3', '\x2', '\x2',
        '\x2', 'o', 'm', '\x3', '\x2', '\x2', '\x2', 'p', 's', '\x5', '&', '\x14',
        '\x2', 'q', 's', '\x5', '\b', '\x5', '\x2', 'r', 'p', '\x3', '\x2', '\x2',
        '\x2', 'r', 'q', '\x3', '\x2', '\x2', '\x2', 's', '\a', '\x3', '\x2',
        '\x2', '\x2', 't', '\xEE', '\a', '!', '\x2', '\x2', 'u', 'y', '\a', '\"',
        '\x2', '\x2', 'v', 'x', '\a', 'P', '\x2', '\x2', 'w', 'v', '\x3', '\x2',
        '\x2', '\x2', 'x', '{', '\x3', '\x2', '\x2', '\x2', 'y', 'w', '\x3', '\x2',
        '\x2', '\x2', 'y', 'z', '\x3', '\x2', '\x2', '\x2', 'z', '|', '\x3', '\x2',
        '\x2', '\x2', '{', 'y', '\x3', '\x2', '\x2', '\x2', '|', '\x80', '\x5',
        '\n', '\x6', '\x2', '}', '\x7F', '\a', 'P', '\x2', '\x2', '~', '}', '\x3',
        '\x2', '\x2', '\x2', '\x7F', '\x82', '\x3', '\x2', '\x2', '\x2', '\x80',
        '~', '\x3', '\x2', '\x2', '\x2', '\x80', '\x81', '\x3', '\x2', '\x2',
        '\x2', '\x81', '\x84', '\x3', '\x2', '\x2', '\x2', '\x82', '\x80', '\x3',
        '\x2', '\x2', '\x2', '\x83', '\x85', '\x5', '\x12', '\n', '\x2', '\x84',
        '\x83', '\x3', '\x2', '\x2', '\x2', '\x84', '\x85', '\x3', '\x2', '\x2',
        '\x2', '\x85', '\x86', '\x3', '\x2', '\x2', '\x2', '\x86', '\x87', '\a',
        '\x37', '\x2', '\x2', '\x87', '\xEE', '\x3', '\x2', '\x2', '\x2', '\x88',
        '\xEE', '\x5', '\f', '\a', '\x2', '\x89', '\x8D', '\a', '\'', '\x2', '\x2',
        '\x8A', '\x8C', '\a', 'P', '\x2', '\x2', '\x8B', '\x8A', '\x3', '\x2',
        '\x2', '\x2', '\x8C', '\x8F', '\x3', '\x2', '\x2', '\x2', '\x8D', '\x8B',
        '\x3', '\x2', '\x2', '\x2', '\x8D', '\x8E', '\x3', '\x2', '\x2', '\x2',
        '\x8E', '\x90', '\x3', '\x2', '\x2', '\x2', '\x8F', '\x8D', '\x3', '\x2',
        '\x2', '\x2', '\x90', '\x94', '\a', '@', '\x2', '\x2', '\x91', '\x93',
        '\a', 'P', '\x2', '\x2', '\x92', '\x91', '\x3', '\x2', '\x2', '\x2', '\x93',
        '\x96', '\x3', '\x2', '\x2', '\x2', '\x94', '\x92', '\x3', '\x2', '\x2',
        '\x2', '\x94', '\x95', '\x3', '\x2', '\x2', '\x2', '\x95', '\x97', '\x3',
        '\x2', '\x2', '\x2', '\x96', '\x94', '\x3', '\x2', '\x2', '\x2', '\x97',
        '\x98', '\x5', '(', '\x15', '\x2', '\x98', '\x99', '\a', '\x41', '\x2',
        '\x2', '\x99', '\xEE', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x9E', '\a',
        '(', '\x2', '\x2', '\x9B', '\x9D', '\a', 'P', '\x2', '\x2', '\x9C', '\x9B',
        '\x3', '\x2', '\x2', '\x2', '\x9D', '\xA0', '\x3', '\x2', '\x2', '\x2',
        '\x9E', '\x9C', '\x3', '\x2', '\x2', '\x2', '\x9E', '\x9F', '\x3', '\x2',
        '\x2', '\x2', '\x9F', '\xA1', '\x3', '\x2', '\x2', '\x2', '\xA0', '\x9E',
        '\x3', '\x2', '\x2', '\x2', '\xA1', '\xA5', '\a', '@', '\x2', '\x2', '\xA2',
        '\xA4', '\a', 'P', '\x2', '\x2', '\xA3', '\xA2', '\x3', '\x2', '\x2',
        '\x2', '\xA4', '\xA7', '\x3', '\x2', '\x2', '\x2', '\xA5', '\xA3', '\x3',
        '\x2', '\x2', '\x2', '\xA5', '\xA6', '\x3', '\x2', '\x2', '\x2', '\xA6',
        '\xA8', '\x3', '\x2', '\x2', '\x2', '\xA7', '\xA5', '\x3', '\x2', '\x2',
        '\x2', '\xA8', '\xA9', '\x5', '(', '\x15', '\x2', '\xA9', '\xAA', '\a',
        '\x41', '\x2', '\x2', '\xAA', '\xEE', '\x3', '\x2', '\x2', '\x2', '\xAB',
        '\xAF', '\a', '$', '\x2', '\x2', '\xAC', '\xAE', '\a', 'P', '\x2', '\x2',
        '\xAD', '\xAC', '\x3', '\x2', '\x2', '\x2', '\xAE', '\xB1', '\x3', '\x2',
        '\x2', '\x2', '\xAF', '\xAD', '\x3', '\x2', '\x2', '\x2', '\xAF', '\xB0',
        '\x3', '\x2', '\x2', '\x2', '\xB0', '\xB3', '\x3', '\x2', '\x2', '\x2',
        '\xB1', '\xAF', '\x3', '\x2', '\x2', '\x2', '\xB2', '\xB4', '\x5', '\x12',
        '\n', '\x2', '\xB3', '\xB2', '\x3', '\x2', '\x2', '\x2', '\xB3', '\xB4',
        '\x3', '\x2', '\x2', '\x2', '\xB4', '\xB5', '\x3', '\x2', '\x2', '\x2',
        '\xB5', '\xB9', '\a', '@', '\x2', '\x2', '\xB6', '\xB8', '\a', 'P', '\x2',
        '\x2', '\xB7', '\xB6', '\x3', '\x2', '\x2', '\x2', '\xB8', '\xBB', '\x3',
        '\x2', '\x2', '\x2', '\xB9', '\xB7', '\x3', '\x2', '\x2', '\x2', '\xB9',
        '\xBA', '\x3', '\x2', '\x2', '\x2', '\xBA', '\xC5', '\x3', '\x2', '\x2',
        '\x2', '\xBB', '\xB9', '\x3', '\x2', '\x2', '\x2', '\xBC', '\xC0', '\x5',
        '\x1A', '\xE', '\x2', '\xBD', '\xBF', '\a', 'P', '\x2', '\x2', '\xBE',
        '\xBD', '\x3', '\x2', '\x2', '\x2', '\xBF', '\xC2', '\x3', '\x2', '\x2',
        '\x2', '\xC0', '\xBE', '\x3', '\x2', '\x2', '\x2', '\xC0', '\xC1', '\x3',
        '\x2', '\x2', '\x2', '\xC1', '\xC4', '\x3', '\x2', '\x2', '\x2', '\xC2',
        '\xC0', '\x3', '\x2', '\x2', '\x2', '\xC3', '\xBC', '\x3', '\x2', '\x2',
        '\x2', '\xC4', '\xC7', '\x3', '\x2', '\x2', '\x2', '\xC5', '\xC3', '\x3',
        '\x2', '\x2', '\x2', '\xC5', '\xC6', '\x3', '\x2', '\x2', '\x2', '\xC6',
        '\xC8', '\x3', '\x2', '\x2', '\x2', '\xC7', '\xC5', '\x3', '\x2', '\x2',
        '\x2', '\xC8', '\xEE', '\a', '\x41', '\x2', '\x2', '\xC9', '\xCD', '\a',
        '#', '\x2', '\x2', '\xCA', '\xCC', '\a', 'P', '\x2', '\x2', '\xCB', '\xCA',
        '\x3', '\x2', '\x2', '\x2', '\xCC', '\xCF', '\x3', '\x2', '\x2', '\x2',
        '\xCD', '\xCB', '\x3', '\x2', '\x2', '\x2', '\xCD', '\xCE', '\x3', '\x2',
        '\x2', '\x2', '\xCE', '\xD0', '\x3', '\x2', '\x2', '\x2', '\xCF', '\xCD',
        '\x3', '\x2', '\x2', '\x2', '\xD0', '\xD4', '\x5', '\x1C', '\xF', '\x2',
        '\xD1', '\xD3', '\a', 'P', '\x2', '\x2', '\xD2', '\xD1', '\x3', '\x2',
        '\x2', '\x2', '\xD3', '\xD6', '\x3', '\x2', '\x2', '\x2', '\xD4', '\xD2',
        '\x3', '\x2', '\x2', '\x2', '\xD4', '\xD5', '\x3', '\x2', '\x2', '\x2',
        '\xD5', '\xD7', '\x3', '\x2', '\x2', '\x2', '\xD6', '\xD4', '\x3', '\x2',
        '\x2', '\x2', '\xD7', '\xDB', '\a', '@', '\x2', '\x2', '\xD8', '\xDA',
        '\a', 'P', '\x2', '\x2', '\xD9', '\xD8', '\x3', '\x2', '\x2', '\x2', '\xDA',
        '\xDD', '\x3', '\x2', '\x2', '\x2', '\xDB', '\xD9', '\x3', '\x2', '\x2',
        '\x2', '\xDB', '\xDC', '\x3', '\x2', '\x2', '\x2', '\xDC', '\xE7', '\x3',
        '\x2', '\x2', '\x2', '\xDD', '\xDB', '\x3', '\x2', '\x2', '\x2', '\xDE',
        '\xE2', '\x5', '\x1E', '\x10', '\x2', '\xDF', '\xE1', '\a', 'P', '\x2',
        '\x2', '\xE0', '\xDF', '\x3', '\x2', '\x2', '\x2', '\xE1', '\xE4', '\x3',
        '\x2', '\x2', '\x2', '\xE2', '\xE0', '\x3', '\x2', '\x2', '\x2', '\xE2',
        '\xE3', '\x3', '\x2', '\x2', '\x2', '\xE3', '\xE6', '\x3', '\x2', '\x2',
        '\x2', '\xE4', '\xE2', '\x3', '\x2', '\x2', '\x2', '\xE5', '\xDE', '\x3',
        '\x2', '\x2', '\x2', '\xE6', '\xE9', '\x3', '\x2', '\x2', '\x2', '\xE7',
        '\xE5', '\x3', '\x2', '\x2', '\x2', '\xE7', '\xE8', '\x3', '\x2', '\x2',
        '\x2', '\xE8', '\xEA', '\x3', '\x2', '\x2', '\x2', '\xE9', '\xE7', '\x3',
        '\x2', '\x2', '\x2', '\xEA', '\xEB', '\a', '\x41', '\x2', '\x2', '\xEB',
        '\xEE', '\x3', '\x2', '\x2', '\x2', '\xEC', '\xEE', '\x5', '\"', '\x12',
        '\x2', '\xED', 't', '\x3', '\x2', '\x2', '\x2', '\xED', 'u', '\x3', '\x2',
        '\x2', '\x2', '\xED', '\x88', '\x3', '\x2', '\x2', '\x2', '\xED', '\x89',
        '\x3', '\x2', '\x2', '\x2', '\xED', '\x9A', '\x3', '\x2', '\x2', '\x2',
        '\xED', '\xAB', '\x3', '\x2', '\x2', '\x2', '\xED', '\xC9', '\x3', '\x2',
        '\x2', '\x2', '\xED', '\xEC', '\x3', '\x2', '\x2', '\x2', '\xEE', '\t',
        '\x3', '\x2', '\x2', '\x2', '\xEF', '\xF0', '\t', '\x2', '\x2', '\x2',
        '\xF0', '\v', '\x3', '\x2', '\x2', '\x2', '\xF1', '\xF5', '\a', '%', '\x2',
        '\x2', '\xF2', '\xF4', '\a', 'P', '\x2', '\x2', '\xF3', '\xF2', '\x3',
        '\x2', '\x2', '\x2', '\xF4', '\xF7', '\x3', '\x2', '\x2', '\x2', '\xF5',
        '\xF3', '\x3', '\x2', '\x2', '\x2', '\xF5', '\xF6', '\x3', '\x2', '\x2',
        '\x2', '\xF6', '\xF9', '\x3', '\x2', '\x2', '\x2', '\xF7', '\xF5', '\x3',
        '\x2', '\x2', '\x2', '\xF8', '\xFA', '\a', ' ', '\x2', '\x2', '\xF9',
        '\xF8', '\x3', '\x2', '\x2', '\x2', '\xF9', '\xFA', '\x3', '\x2', '\x2',
        '\x2', '\xFA', '\xFC', '\x3', '\x2', '\x2', '\x2', '\xFB', '\xFD', '\x5',
        '\x46', '$', '\x2', '\xFC', '\xFB', '\x3', '\x2', '\x2', '\x2', '\xFC',
        '\xFD', '\x3', '\x2', '\x2', '\x2', '\xFD', '\x101', '\x3', '\x2', '\x2',
        '\x2', '\xFE', '\x100', '\a', 'P', '\x2', '\x2', '\xFF', '\xFE', '\x3',
        '\x2', '\x2', '\x2', '\x100', '\x103', '\x3', '\x2', '\x2', '\x2', '\x101',
        '\xFF', '\x3', '\x2', '\x2', '\x2', '\x101', '\x102', '\x3', '\x2', '\x2',
        '\x2', '\x102', '\x104', '\x3', '\x2', '\x2', '\x2', '\x103', '\x101',
        '\x3', '\x2', '\x2', '\x2', '\x104', '\x108', '\a', '@', '\x2', '\x2',
        '\x105', '\x107', '\a', 'P', '\x2', '\x2', '\x106', '\x105', '\x3', '\x2',
        '\x2', '\x2', '\x107', '\x10A', '\x3', '\x2', '\x2', '\x2', '\x108', '\x106',
        '\x3', '\x2', '\x2', '\x2', '\x108', '\x109', '\x3', '\x2', '\x2', '\x2',
        '\x109', '\x10B', '\x3', '\x2', '\x2', '\x2', '\x10A', '\x108', '\x3',
        '\x2', '\x2', '\x2', '\x10B', '\x10F', '\x5', '(', '\x15', '\x2', '\x10C',
        '\x10E', '\x5', '\xE', '\b', '\x2', '\x10D', '\x10C', '\x3', '\x2', '\x2',
        '\x2', '\x10E', '\x111', '\x3', '\x2', '\x2', '\x2', '\x10F', '\x10D',
        '\x3', '\x2', '\x2', '\x2', '\x10F', '\x110', '\x3', '\x2', '\x2', '\x2',
        '\x110', '\x112', '\x3', '\x2', '\x2', '\x2', '\x111', '\x10F', '\x3',
        '\x2', '\x2', '\x2', '\x112', '\x113', '\a', '\x41', '\x2', '\x2', '\x113',
        '\r', '\x3', '\x2', '\x2', '\x2', '\x114', '\x118', '\a', '&', '\x2',
        '\x2', '\x115', '\x117', '\a', 'P', '\x2', '\x2', '\x116', '\x115', '\x3',
        '\x2', '\x2', '\x2', '\x117', '\x11A', '\x3', '\x2', '\x2', '\x2', '\x118',
        '\x116', '\x3', '\x2', '\x2', '\x2', '\x118', '\x119', '\x3', '\x2', '\x2',
        '\x2', '\x119', '\x11B', '\x3', '\x2', '\x2', '\x2', '\x11A', '\x118',
        '\x3', '\x2', '\x2', '\x2', '\x11B', '\x11F', '\a', '@', '\x2', '\x2',
        '\x11C', '\x11E', '\a', 'P', '\x2', '\x2', '\x11D', '\x11C', '\x3', '\x2',
        '\x2', '\x2', '\x11E', '\x121', '\x3', '\x2', '\x2', '\x2', '\x11F', '\x11D',
        '\x3', '\x2', '\x2', '\x2', '\x11F', '\x120', '\x3', '\x2', '\x2', '\x2',
        '\x120', '\x122', '\x3', '\x2', '\x2', '\x2', '\x121', '\x11F', '\x3',
        '\x2', '\x2', '\x2', '\x122', '\x123', '\x5', '(', '\x15', '\x2', '\x123',
        '\x127', '\a', '\x41', '\x2', '\x2', '\x124', '\x126', '\a', 'P', '\x2',
        '\x2', '\x125', '\x124', '\x3', '\x2', '\x2', '\x2', '\x126', '\x129',
        '\x3', '\x2', '\x2', '\x2', '\x127', '\x125', '\x3', '\x2', '\x2', '\x2',
        '\x127', '\x128', '\x3', '\x2', '\x2', '\x2', '\x128', '\xF', '\x3', '\x2',
        '\x2', '\x2', '\x129', '\x127', '\x3', '\x2', '\x2', '\x2', '\x12A', '\x12E',
        '\x5', '\x46', '$', '\x2', '\x12B', '\x12D', '\a', 'P', '\x2', '\x2',
        '\x12C', '\x12B', '\x3', '\x2', '\x2', '\x2', '\x12D', '\x130', '\x3',
        '\x2', '\x2', '\x2', '\x12E', '\x12C', '\x3', '\x2', '\x2', '\x2', '\x12E',
        '\x12F', '\x3', '\x2', '\x2', '\x2', '\x12F', '\x141', '\x3', '\x2', '\x2',
        '\x2', '\x130', '\x12E', '\x3', '\x2', '\x2', '\x2', '\x131', '\x135',
        '\a', '\x39', '\x2', '\x2', '\x132', '\x134', '\a', 'P', '\x2', '\x2',
        '\x133', '\x132', '\x3', '\x2', '\x2', '\x2', '\x134', '\x137', '\x3',
        '\x2', '\x2', '\x2', '\x135', '\x133', '\x3', '\x2', '\x2', '\x2', '\x135',
        '\x136', '\x3', '\x2', '\x2', '\x2', '\x136', '\x138', '\x3', '\x2', '\x2',
        '\x2', '\x137', '\x135', '\x3', '\x2', '\x2', '\x2', '\x138', '\x13C',
        '\x5', '\x46', '$', '\x2', '\x139', '\x13B', '\a', 'P', '\x2', '\x2',
        '\x13A', '\x139', '\x3', '\x2', '\x2', '\x2', '\x13B', '\x13E', '\x3',
        '\x2', '\x2', '\x2', '\x13C', '\x13A', '\x3', '\x2', '\x2', '\x2', '\x13C',
        '\x13D', '\x3', '\x2', '\x2', '\x2', '\x13D', '\x140', '\x3', '\x2', '\x2',
        '\x2', '\x13E', '\x13C', '\x3', '\x2', '\x2', '\x2', '\x13F', '\x131',
        '\x3', '\x2', '\x2', '\x2', '\x140', '\x143', '\x3', '\x2', '\x2', '\x2',
        '\x141', '\x13F', '\x3', '\x2', '\x2', '\x2', '\x141', '\x142', '\x3',
        '\x2', '\x2', '\x2', '\x142', '\x145', '\x3', '\x2', '\x2', '\x2', '\x143',
        '\x141', '\x3', '\x2', '\x2', '\x2', '\x144', '\x12A', '\x3', '\x2', '\x2',
        '\x2', '\x144', '\x145', '\x3', '\x2', '\x2', '\x2', '\x145', '\x146',
        '\x3', '\x2', '\x2', '\x2', '\x146', '\x147', '\a', '@', '\x2', '\x2',
        '\x147', '\x148', '\x5', '(', '\x15', '\x2', '\x148', '\x149', '\a', '\x41',
        '\x2', '\x2', '\x149', '\x11', '\x3', '\x2', '\x2', '\x2', '\x14A', '\x155',
        '\x5', '\x14', '\v', '\x2', '\x14B', '\x14F', '\a', '\x39', '\x2', '\x2',
        '\x14C', '\x14E', '\a', 'P', '\x2', '\x2', '\x14D', '\x14C', '\x3', '\x2',
        '\x2', '\x2', '\x14E', '\x151', '\x3', '\x2', '\x2', '\x2', '\x14F', '\x14D',
        '\x3', '\x2', '\x2', '\x2', '\x14F', '\x150', '\x3', '\x2', '\x2', '\x2',
        '\x150', '\x152', '\x3', '\x2', '\x2', '\x2', '\x151', '\x14F', '\x3',
        '\x2', '\x2', '\x2', '\x152', '\x154', '\x5', '\x14', '\v', '\x2', '\x153',
        '\x14B', '\x3', '\x2', '\x2', '\x2', '\x154', '\x157', '\x3', '\x2', '\x2',
        '\x2', '\x155', '\x153', '\x3', '\x2', '\x2', '\x2', '\x155', '\x156',
        '\x3', '\x2', '\x2', '\x2', '\x156', '\x13', '\x3', '\x2', '\x2', '\x2',
        '\x157', '\x155', '\x3', '\x2', '\x2', '\x2', '\x158', '\x15C', '\x5',
        '\x16', '\f', '\x2', '\x159', '\x15B', '\a', 'P', '\x2', '\x2', '\x15A',
        '\x159', '\x3', '\x2', '\x2', '\x2', '\x15B', '\x15E', '\x3', '\x2', '\x2',
        '\x2', '\x15C', '\x15A', '\x3', '\x2', '\x2', '\x2', '\x15C', '\x15D',
        '\x3', '\x2', '\x2', '\x2', '\x15D', '\x160', '\x3', '\x2', '\x2', '\x2',
        '\x15E', '\x15C', '\x3', '\x2', '\x2', '\x2', '\x15F', '\x158', '\x3',
        '\x2', '\x2', '\x2', '\x160', '\x161', '\x3', '\x2', '\x2', '\x2', '\x161',
        '\x15F', '\x3', '\x2', '\x2', '\x2', '\x161', '\x162', '\x3', '\x2', '\x2',
        '\x2', '\x162', '\x15', '\x3', '\x2', '\x2', '\x2', '\x163', '\x166',
        '\a', ' ', '\x2', '\x2', '\x164', '\x166', '\x5', '\x18', '\r', '\x2',
        '\x165', '\x163', '\x3', '\x2', '\x2', '\x2', '\x165', '\x164', '\x3',
        '\x2', '\x2', '\x2', '\x166', '\x169', '\x3', '\x2', '\x2', '\x2', '\x167',
        '\x169', '\x5', 'V', ',', '\x2', '\x168', '\x165', '\x3', '\x2', '\x2',
        '\x2', '\x168', '\x167', '\x3', '\x2', '\x2', '\x2', '\x169', '\x17',
        '\x3', '\x2', '\x2', '\x2', '\x16A', '\x16E', '\a', '\x44', '\x2', '\x2',
        '\x16B', '\x16D', '\a', 'P', '\x2', '\x2', '\x16C', '\x16B', '\x3', '\x2',
        '\x2', '\x2', '\x16D', '\x170', '\x3', '\x2', '\x2', '\x2', '\x16E', '\x16C',
        '\x3', '\x2', '\x2', '\x2', '\x16E', '\x16F', '\x3', '\x2', '\x2', '\x2',
        '\x16F', '\x171', '\x3', '\x2', '\x2', '\x2', '\x170', '\x16E', '\x3',
        '\x2', '\x2', '\x2', '\x171', '\x175', '\a', ' ', '\x2', '\x2', '\x172',
        '\x174', '\a', 'P', '\x2', '\x2', '\x173', '\x172', '\x3', '\x2', '\x2',
        '\x2', '\x174', '\x177', '\x3', '\x2', '\x2', '\x2', '\x175', '\x173',
        '\x3', '\x2', '\x2', '\x2', '\x175', '\x176', '\x3', '\x2', '\x2', '\x2',
        '\x176', '\x180', '\x3', '\x2', '\x2', '\x2', '\x177', '\x175', '\x3',
        '\x2', '\x2', '\x2', '\x178', '\x17C', '\a', '\x38', '\x2', '\x2', '\x179',
        '\x17B', '\a', 'P', '\x2', '\x2', '\x17A', '\x179', '\x3', '\x2', '\x2',
        '\x2', '\x17B', '\x17E', '\x3', '\x2', '\x2', '\x2', '\x17C', '\x17A',
        '\x3', '\x2', '\x2', '\x2', '\x17C', '\x17D', '\x3', '\x2', '\x2', '\x2',
        '\x17D', '\x17F', '\x3', '\x2', '\x2', '\x2', '\x17E', '\x17C', '\x3',
        '\x2', '\x2', '\x2', '\x17F', '\x181', '\x5', '\x30', '\x19', '\x2', '\x180',
        '\x178', '\x3', '\x2', '\x2', '\x2', '\x180', '\x181', '\x3', '\x2', '\x2',
        '\x2', '\x181', '\x182', '\x3', '\x2', '\x2', '\x2', '\x182', '\x183',
        '\a', '\x45', '\x2', '\x2', '\x183', '\x19', '\x3', '\x2', '\x2', '\x2',
        '\x184', '\x187', '\x5', '&', '\x14', '\x2', '\x185', '\x187', '\x5',
        '\b', '\x5', '\x2', '\x186', '\x184', '\x3', '\x2', '\x2', '\x2', '\x186',
        '\x185', '\x3', '\x2', '\x2', '\x2', '\x187', '\x1B', '\x3', '\x2', '\x2',
        '\x2', '\x188', '\x18B', '\a', ' ', '\x2', '\x2', '\x189', '\x18B', '\x5',
        'H', '%', '\x2', '\x18A', '\x188', '\x3', '\x2', '\x2', '\x2', '\x18A',
        '\x189', '\x3', '\x2', '\x2', '\x2', '\x18B', '\x1D', '\x3', '\x2', '\x2',
        '\x2', '\x18C', '\x197', '\x5', ' ', '\x11', '\x2', '\x18D', '\x191',
        '\a', '\x39', '\x2', '\x2', '\x18E', '\x190', '\a', 'P', '\x2', '\x2',
        '\x18F', '\x18E', '\x3', '\x2', '\x2', '\x2', '\x190', '\x193', '\x3',
        '\x2', '\x2', '\x2', '\x191', '\x18F', '\x3', '\x2', '\x2', '\x2', '\x191',
        '\x192', '\x3', '\x2', '\x2', '\x2', '\x192', '\x194', '\x3', '\x2', '\x2',
        '\x2', '\x193', '\x191', '\x3', '\x2', '\x2', '\x2', '\x194', '\x196',
        '\x5', ' ', '\x11', '\x2', '\x195', '\x18D', '\x3', '\x2', '\x2', '\x2',
        '\x196', '\x199', '\x3', '\x2', '\x2', '\x2', '\x197', '\x195', '\x3',
        '\x2', '\x2', '\x2', '\x197', '\x198', '\x3', '\x2', '\x2', '\x2', '\x198',
        '\x19A', '\x3', '\x2', '\x2', '\x2', '\x199', '\x197', '\x3', '\x2', '\x2',
        '\x2', '\x19A', '\x19E', '\a', '@', '\x2', '\x2', '\x19B', '\x19D', '\a',
        'P', '\x2', '\x2', '\x19C', '\x19B', '\x3', '\x2', '\x2', '\x2', '\x19D',
        '\x1A0', '\x3', '\x2', '\x2', '\x2', '\x19E', '\x19C', '\x3', '\x2', '\x2',
        '\x2', '\x19E', '\x19F', '\x3', '\x2', '\x2', '\x2', '\x19F', '\x1A1',
        '\x3', '\x2', '\x2', '\x2', '\x1A0', '\x19E', '\x3', '\x2', '\x2', '\x2',
        '\x1A1', '\x1A2', '\x5', '(', '\x15', '\x2', '\x1A2', '\x1A3', '\a', '\x41',
        '\x2', '\x2', '\x1A3', '\x1F', '\x3', '\x2', '\x2', '\x2', '\x1A4', '\x1A8',
        '\a', ' ', '\x2', '\x2', '\x1A5', '\x1A7', '\a', 'P', '\x2', '\x2', '\x1A6',
        '\x1A5', '\x3', '\x2', '\x2', '\x2', '\x1A7', '\x1AA', '\x3', '\x2', '\x2',
        '\x2', '\x1A8', '\x1A6', '\x3', '\x2', '\x2', '\x2', '\x1A8', '\x1A9',
        '\x3', '\x2', '\x2', '\x2', '\x1A9', '\x1B3', '\x3', '\x2', '\x2', '\x2',
        '\x1AA', '\x1A8', '\x3', '\x2', '\x2', '\x2', '\x1AB', '\x1AF', '\a',
        '\x30', '\x2', '\x2', '\x1AC', '\x1AE', '\a', 'P', '\x2', '\x2', '\x1AD',
        '\x1AC', '\x3', '\x2', '\x2', '\x2', '\x1AE', '\x1B1', '\x3', '\x2', '\x2',
        '\x2', '\x1AF', '\x1AD', '\x3', '\x2', '\x2', '\x2', '\x1AF', '\x1B0',
        '\x3', '\x2', '\x2', '\x2', '\x1B0', '\x1B3', '\x3', '\x2', '\x2', '\x2',
        '\x1B1', '\x1AF', '\x3', '\x2', '\x2', '\x2', '\x1B2', '\x1A4', '\x3',
        '\x2', '\x2', '\x2', '\x1B2', '\x1AB', '\x3', '\x2', '\x2', '\x2', '\x1B3',
        '!', '\x3', '\x2', '\x2', '\x2', '\x1B4', '\x1B8', '\a', ')', '\x2', '\x2',
        '\x1B5', '\x1B7', '\a', 'P', '\x2', '\x2', '\x1B6', '\x1B5', '\x3', '\x2',
        '\x2', '\x2', '\x1B7', '\x1BA', '\x3', '\x2', '\x2', '\x2', '\x1B8', '\x1B6',
        '\x3', '\x2', '\x2', '\x2', '\x1B8', '\x1B9', '\x3', '\x2', '\x2', '\x2',
        '\x1B9', '\x1BE', '\x3', '\x2', '\x2', '\x2', '\x1BA', '\x1B8', '\x3',
        '\x2', '\x2', '\x2', '\x1BB', '\x1BD', '\x5', 'N', '(', '\x2', '\x1BC',
        '\x1BB', '\x3', '\x2', '\x2', '\x2', '\x1BD', '\x1C0', '\x3', '\x2', '\x2',
        '\x2', '\x1BE', '\x1BC', '\x3', '\x2', '\x2', '\x2', '\x1BE', '\x1BF',
        '\x3', '\x2', '\x2', '\x2', '\x1BF', '\x1C1', '\x3', '\x2', '\x2', '\x2',
        '\x1C0', '\x1BE', '\x3', '\x2', '\x2', '\x2', '\x1C1', '\x1D1', '\x5',
        '$', '\x13', '\x2', '\x1C2', '\x1C6', '\a', ')', '\x2', '\x2', '\x1C3',
        '\x1C5', '\a', 'P', '\x2', '\x2', '\x1C4', '\x1C3', '\x3', '\x2', '\x2',
        '\x2', '\x1C5', '\x1C8', '\x3', '\x2', '\x2', '\x2', '\x1C6', '\x1C4',
        '\x3', '\x2', '\x2', '\x2', '\x1C6', '\x1C7', '\x3', '\x2', '\x2', '\x2',
        '\x1C7', '\x1CC', '\x3', '\x2', '\x2', '\x2', '\x1C8', '\x1C6', '\x3',
        '\x2', '\x2', '\x2', '\x1C9', '\x1CB', '\x5', 'N', '(', '\x2', '\x1CA',
        '\x1C9', '\x3', '\x2', '\x2', '\x2', '\x1CB', '\x1CE', '\x3', '\x2', '\x2',
        '\x2', '\x1CC', '\x1CA', '\x3', '\x2', '\x2', '\x2', '\x1CC', '\x1CD',
        '\x3', '\x2', '\x2', '\x2', '\x1CD', '\x1CF', '\x3', '\x2', '\x2', '\x2',
        '\x1CE', '\x1CC', '\x3', '\x2', '\x2', '\x2', '\x1CF', '\x1D1', '\a',
        '\x37', '\x2', '\x2', '\x1D0', '\x1B4', '\x3', '\x2', '\x2', '\x2', '\x1D0',
        '\x1C2', '\x3', '\x2', '\x2', '\x2', '\x1D1', '#', '\x3', '\x2', '\x2',
        '\x2', '\x1D2', '\x1D6', '\a', '@', '\x2', '\x2', '\x1D3', '\x1D5', '\a',
        'P', '\x2', '\x2', '\x1D4', '\x1D3', '\x3', '\x2', '\x2', '\x2', '\x1D5',
        '\x1D8', '\x3', '\x2', '\x2', '\x2', '\x1D6', '\x1D4', '\x3', '\x2', '\x2',
        '\x2', '\x1D6', '\x1D7', '\x3', '\x2', '\x2', '\x2', '\x1D7', '\x1D9',
        '\x3', '\x2', '\x2', '\x2', '\x1D8', '\x1D6', '\x3', '\x2', '\x2', '\x2',
        '\x1D9', '\x1DA', '\a', '\x41', '\x2', '\x2', '\x1DA', '%', '\x3', '\x2',
        '\x2', '\x2', '\x1DB', '\x1E6', '\x5', '<', '\x1F', '\x2', '\x1DC', '\x1E0',
        '\a', '\x39', '\x2', '\x2', '\x1DD', '\x1DF', '\a', 'P', '\x2', '\x2',
        '\x1DE', '\x1DD', '\x3', '\x2', '\x2', '\x2', '\x1DF', '\x1E2', '\x3',
        '\x2', '\x2', '\x2', '\x1E0', '\x1DE', '\x3', '\x2', '\x2', '\x2', '\x1E0',
        '\x1E1', '\x3', '\x2', '\x2', '\x2', '\x1E1', '\x1E3', '\x3', '\x2', '\x2',
        '\x2', '\x1E2', '\x1E0', '\x3', '\x2', '\x2', '\x2', '\x1E3', '\x1E5',
        '\x5', '<', '\x1F', '\x2', '\x1E4', '\x1DC', '\x3', '\x2', '\x2', '\x2',
        '\x1E5', '\x1E8', '\x3', '\x2', '\x2', '\x2', '\x1E6', '\x1E4', '\x3',
        '\x2', '\x2', '\x2', '\x1E6', '\x1E7', '\x3', '\x2', '\x2', '\x2', '\x1E7',
        '\x1EA', '\x3', '\x2', '\x2', '\x2', '\x1E8', '\x1E6', '\x3', '\x2', '\x2',
        '\x2', '\x1E9', '\x1DB', '\x3', '\x2', '\x2', '\x2', '\x1E9', '\x1EA',
        '\x3', '\x2', '\x2', '\x2', '\x1EA', '\x1EB', '\x3', '\x2', '\x2', '\x2',
        '\x1EB', '\x1EF', '\a', '@', '\x2', '\x2', '\x1EC', '\x1EE', '\a', 'P',
        '\x2', '\x2', '\x1ED', '\x1EC', '\x3', '\x2', '\x2', '\x2', '\x1EE', '\x1F1',
        '\x3', '\x2', '\x2', '\x2', '\x1EF', '\x1ED', '\x3', '\x2', '\x2', '\x2',
        '\x1EF', '\x1F0', '\x3', '\x2', '\x2', '\x2', '\x1F0', '\x1F2', '\x3',
        '\x2', '\x2', '\x2', '\x1F1', '\x1EF', '\x3', '\x2', '\x2', '\x2', '\x1F2',
        '\x1F3', '\x5', '(', '\x15', '\x2', '\x1F3', '\x1F4', '\a', '\x41', '\x2',
        '\x2', '\x1F4', '\x1F9', '\x3', '\x2', '\x2', '\x2', '\x1F5', '\x1F6',
        '\x5', 'T', '+', '\x2', '\x1F6', '\x1F7', '\b', '\x14', '\x1', '\x2',
        '\x1F7', '\x1F9', '\x3', '\x2', '\x2', '\x2', '\x1F8', '\x1E9', '\x3',
        '\x2', '\x2', '\x2', '\x1F8', '\x1F5', '\x3', '\x2', '\x2', '\x2', '\x1F9',
        '\'', '\x3', '\x2', '\x2', '\x2', '\x1FA', '\x1FC', '\x5', '*', '\x16',
        '\x2', '\x1FB', '\x1FA', '\x3', '\x2', '\x2', '\x2', '\x1FB', '\x1FC',
        '\x3', '\x2', '\x2', '\x2', '\x1FC', '\x209', '\x3', '\x2', '\x2', '\x2',
        '\x1FD', '\x201', '\a', '\x37', '\x2', '\x2', '\x1FE', '\x200', '\a',
        'P', '\x2', '\x2', '\x1FF', '\x1FE', '\x3', '\x2', '\x2', '\x2', '\x200',
        '\x203', '\x3', '\x2', '\x2', '\x2', '\x201', '\x1FF', '\x3', '\x2', '\x2',
        '\x2', '\x201', '\x202', '\x3', '\x2', '\x2', '\x2', '\x202', '\x205',
        '\x3', '\x2', '\x2', '\x2', '\x203', '\x201', '\x3', '\x2', '\x2', '\x2',
        '\x204', '\x206', '\x5', '*', '\x16', '\x2', '\x205', '\x204', '\x3',
        '\x2', '\x2', '\x2', '\x205', '\x206', '\x3', '\x2', '\x2', '\x2', '\x206',
        '\x208', '\x3', '\x2', '\x2', '\x2', '\x207', '\x1FD', '\x3', '\x2', '\x2',
        '\x2', '\x208', '\x20B', '\x3', '\x2', '\x2', '\x2', '\x209', '\x207',
        '\x3', '\x2', '\x2', '\x2', '\x209', '\x20A', '\x3', '\x2', '\x2', '\x2',
        '\x20A', ')', '\x3', '\x2', '\x2', '\x2', '\x20B', '\x209', '\x3', '\x2',
        '\x2', '\x2', '\x20C', '\x20D', '\x5', '.', '\x18', '\x2', '\x20D', '\x211',
        '\a', '\x38', '\x2', '\x2', '\x20E', '\x210', '\a', 'P', '\x2', '\x2',
        '\x20F', '\x20E', '\x3', '\x2', '\x2', '\x2', '\x210', '\x213', '\x3',
        '\x2', '\x2', '\x2', '\x211', '\x20F', '\x3', '\x2', '\x2', '\x2', '\x211',
        '\x212', '\x3', '\x2', '\x2', '\x2', '\x212', '\x215', '\x3', '\x2', '\x2',
        '\x2', '\x213', '\x211', '\x3', '\x2', '\x2', '\x2', '\x214', '\x216',
        '\x5', '\x30', '\x19', '\x2', '\x215', '\x214', '\x3', '\x2', '\x2', '\x2',
        '\x215', '\x216', '\x3', '\x2', '\x2', '\x2', '\x216', '\x218', '\x3',
        '\x2', '\x2', '\x2', '\x217', '\x219', '\x5', ',', '\x17', '\x2', '\x218',
        '\x217', '\x3', '\x2', '\x2', '\x2', '\x218', '\x219', '\x3', '\x2', '\x2',
        '\x2', '\x219', '\x222', '\x3', '\x2', '\x2', '\x2', '\x21A', '\x21E',
        '\x5', 'R', '*', '\x2', '\x21B', '\x21D', '\x5', 'N', '(', '\x2', '\x21C',
        '\x21B', '\x3', '\x2', '\x2', '\x2', '\x21D', '\x220', '\x3', '\x2', '\x2',
        '\x2', '\x21E', '\x21C', '\x3', '\x2', '\x2', '\x2', '\x21E', '\x21F',
        '\x3', '\x2', '\x2', '\x2', '\x21F', '\x222', '\x3', '\x2', '\x2', '\x2',
        '\x220', '\x21E', '\x3', '\x2', '\x2', '\x2', '\x221', '\x20C', '\x3',
        '\x2', '\x2', '\x2', '\x221', '\x21A', '\x3', '\x2', '\x2', '\x2', '\x222',
        '+', '\x3', '\x2', '\x2', '\x2', '\x223', '\x227', '\a', 'H', '\x2', '\x2',
        '\x224', '\x226', '\a', 'P', '\x2', '\x2', '\x225', '\x224', '\x3', '\x2',
        '\x2', '\x2', '\x226', '\x229', '\x3', '\x2', '\x2', '\x2', '\x227', '\x225',
        '\x3', '\x2', '\x2', '\x2', '\x227', '\x228', '\x3', '\x2', '\x2', '\x2',
        '\x228', '\x22A', '\x3', '\x2', '\x2', '\x2', '\x229', '\x227', '\x3',
        '\x2', '\x2', '\x2', '\x22A', '\x22E', '\a', '\x1F', '\x2', '\x2', '\x22B',
        '\x22D', '\a', 'P', '\x2', '\x2', '\x22C', '\x22B', '\x3', '\x2', '\x2',
        '\x2', '\x22D', '\x230', '\x3', '\x2', '\x2', '\x2', '\x22E', '\x22C',
        '\x3', '\x2', '\x2', '\x2', '\x22E', '\x22F', '\x3', '\x2', '\x2', '\x2',
        '\x22F', '-', '\x3', '\x2', '\x2', '\x2', '\x230', '\x22E', '\x3', '\x2',
        '\x2', '\x2', '\x231', '\x233', '\a', 'J', '\x2', '\x2', '\x232', '\x231',
        '\x3', '\x2', '\x2', '\x2', '\x232', '\x233', '\x3', '\x2', '\x2', '\x2',
        '\x233', '\x234', '\x3', '\x2', '\x2', '\x2', '\x234', '\x238', '\a',
        ' ', '\x2', '\x2', '\x235', '\x237', '\a', 'P', '\x2', '\x2', '\x236',
        '\x235', '\x3', '\x2', '\x2', '\x2', '\x237', '\x23A', '\x3', '\x2', '\x2',
        '\x2', '\x238', '\x236', '\x3', '\x2', '\x2', '\x2', '\x238', '\x239',
        '\x3', '\x2', '\x2', '\x2', '\x239', '/', '\x3', '\x2', '\x2', '\x2',
        '\x23A', '\x238', '\x3', '\x2', '\x2', '\x2', '\x23B', '\x23D', '\x5',
        '\x32', '\x1A', '\x2', '\x23C', '\x23B', '\x3', '\x2', '\x2', '\x2', '\x23D',
        '\x23E', '\x3', '\x2', '\x2', '\x2', '\x23E', '\x23C', '\x3', '\x2', '\x2',
        '\x2', '\x23E', '\x23F', '\x3', '\x2', '\x2', '\x2', '\x23F', '\x31',
        '\x3', '\x2', '\x2', '\x2', '\x240', '\x25E', '\x5', '\x36', '\x1C', '\x2',
        '\x241', '\x245', '\a', '@', '\x2', '\x2', '\x242', '\x244', '\a', 'P',
        '\x2', '\x2', '\x243', '\x242', '\x3', '\x2', '\x2', '\x2', '\x244', '\x247',
        '\x3', '\x2', '\x2', '\x2', '\x245', '\x243', '\x3', '\x2', '\x2', '\x2',
        '\x245', '\x246', '\x3', '\x2', '\x2', '\x2', '\x246', '\x252', '\x3',
        '\x2', '\x2', '\x2', '\x247', '\x245', '\x3', '\x2', '\x2', '\x2', '\x248',
        '\x251', '\x5', 'N', '(', '\x2', '\x249', '\x24D', '\a', '\x37', '\x2',
        '\x2', '\x24A', '\x24C', '\a', 'P', '\x2', '\x2', '\x24B', '\x24A', '\x3',
        '\x2', '\x2', '\x2', '\x24C', '\x24F', '\x3', '\x2', '\x2', '\x2', '\x24D',
        '\x24B', '\x3', '\x2', '\x2', '\x2', '\x24D', '\x24E', '\x3', '\x2', '\x2',
        '\x2', '\x24E', '\x251', '\x3', '\x2', '\x2', '\x2', '\x24F', '\x24D',
        '\x3', '\x2', '\x2', '\x2', '\x250', '\x248', '\x3', '\x2', '\x2', '\x2',
        '\x250', '\x249', '\x3', '\x2', '\x2', '\x2', '\x251', '\x254', '\x3',
        '\x2', '\x2', '\x2', '\x252', '\x250', '\x3', '\x2', '\x2', '\x2', '\x252',
        '\x253', '\x3', '\x2', '\x2', '\x2', '\x253', '\x255', '\x3', '\x2', '\x2',
        '\x2', '\x254', '\x252', '\x3', '\x2', '\x2', '\x2', '\x255', '\x25E',
        '\a', '\x41', '\x2', '\x2', '\x256', '\x25A', '\a', ')', '\x2', '\x2',
        '\x257', '\x259', '\a', 'P', '\x2', '\x2', '\x258', '\x257', '\x3', '\x2',
        '\x2', '\x2', '\x259', '\x25C', '\x3', '\x2', '\x2', '\x2', '\x25A', '\x258',
        '\x3', '\x2', '\x2', '\x2', '\x25A', '\x25B', '\x3', '\x2', '\x2', '\x2',
        '\x25B', '\x25E', '\x3', '\x2', '\x2', '\x2', '\x25C', '\x25A', '\x3',
        '\x2', '\x2', '\x2', '\x25D', '\x240', '\x3', '\x2', '\x2', '\x2', '\x25D',
        '\x241', '\x3', '\x2', '\x2', '\x2', '\x25D', '\x256', '\x3', '\x2', '\x2',
        '\x2', '\x25E', '\x33', '\x3', '\x2', '\x2', '\x2', '\x25F', '\x263',
        '\a', 'S', '\x2', '\x2', '\x260', '\x262', '\a', 'P', '\x2', '\x2', '\x261',
        '\x260', '\x3', '\x2', '\x2', '\x2', '\x262', '\x265', '\x3', '\x2', '\x2',
        '\x2', '\x263', '\x261', '\x3', '\x2', '\x2', '\x2', '\x263', '\x264',
        '\x3', '\x2', '\x2', '\x2', '\x264', '\x270', '\x3', '\x2', '\x2', '\x2',
        '\x265', '\x263', '\x3', '\x2', '\x2', '\x2', '\x266', '\x26F', '\x5',
        'N', '(', '\x2', '\x267', '\x26B', '\a', '\x37', '\x2', '\x2', '\x268',
        '\x26A', '\a', 'P', '\x2', '\x2', '\x269', '\x268', '\x3', '\x2', '\x2',
        '\x2', '\x26A', '\x26D', '\x3', '\x2', '\x2', '\x2', '\x26B', '\x269',
        '\x3', '\x2', '\x2', '\x2', '\x26B', '\x26C', '\x3', '\x2', '\x2', '\x2',
        '\x26C', '\x26F', '\x3', '\x2', '\x2', '\x2', '\x26D', '\x26B', '\x3',
        '\x2', '\x2', '\x2', '\x26E', '\x266', '\x3', '\x2', '\x2', '\x2', '\x26E',
        '\x267', '\x3', '\x2', '\x2', '\x2', '\x26F', '\x272', '\x3', '\x2', '\x2',
        '\x2', '\x270', '\x26E', '\x3', '\x2', '\x2', '\x2', '\x270', '\x271',
        '\x3', '\x2', '\x2', '\x2', '\x271', '\x273', '\x3', '\x2', '\x2', '\x2',
        '\x272', '\x270', '\x3', '\x2', '\x2', '\x2', '\x273', '\x280', '\a',
        '\x45', '\x2', '\x2', '\x274', '\x278', '\a', 'T', '\x2', '\x2', '\x275',
        '\x277', '\a', 'P', '\x2', '\x2', '\x276', '\x275', '\x3', '\x2', '\x2',
        '\x2', '\x277', '\x27A', '\x3', '\x2', '\x2', '\x2', '\x278', '\x276',
        '\x3', '\x2', '\x2', '\x2', '\x278', '\x279', '\x3', '\x2', '\x2', '\x2',
        '\x279', '\x27C', '\x3', '\x2', '\x2', '\x2', '\x27A', '\x278', '\x3',
        '\x2', '\x2', '\x2', '\x27B', '\x27D', '\x5', '\x38', '\x1D', '\x2', '\x27C',
        '\x27B', '\x3', '\x2', '\x2', '\x2', '\x27C', '\x27D', '\x3', '\x2', '\x2',
        '\x2', '\x27D', '\x27E', '\x3', '\x2', '\x2', '\x2', '\x27E', '\x280',
        '\a', '\x45', '\x2', '\x2', '\x27F', '\x25F', '\x3', '\x2', '\x2', '\x2',
        '\x27F', '\x274', '\x3', '\x2', '\x2', '\x2', '\x280', '\x35', '\x3',
        '\x2', '\x2', '\x2', '\x281', '\x283', '\a', 'J', '\x2', '\x2', '\x282',
        '\x281', '\x3', '\x2', '\x2', '\x2', '\x282', '\x283', '\x3', '\x2', '\x2',
        '\x2', '\x283', '\x284', '\x3', '\x2', '\x2', '\x2', '\x284', '\x2B0',
        '\a', ' ', '\x2', '\x2', '\x285', '\x287', '\t', '\x3', '\x2', '\x2',
        '\x286', '\x285', '\x3', '\x2', '\x2', '\x2', '\x286', '\x287', '\x3',
        '\x2', '\x2', '\x2', '\x287', '\x288', '\x3', '\x2', '\x2', '\x2', '\x288',
        '\x2B0', '\a', '/', '\x2', '\x2', '\x289', '\x28B', '\t', '\x3', '\x2',
        '\x2', '\x28A', '\x289', '\x3', '\x2', '\x2', '\x2', '\x28A', '\x28B',
        '\x3', '\x2', '\x2', '\x2', '\x28B', '\x28C', '\x3', '\x2', '\x2', '\x2',
        '\x28C', '\x2B0', '\a', '\x30', '\x2', '\x2', '\x28D', '\x28F', '\t',
        '\x3', '\x2', '\x2', '\x28E', '\x28D', '\x3', '\x2', '\x2', '\x2', '\x28E',
        '\x28F', '\x3', '\x2', '\x2', '\x2', '\x28F', '\x290', '\x3', '\x2', '\x2',
        '\x2', '\x290', '\x2B0', '\a', '\x31', '\x2', '\x2', '\x291', '\x2B0',
        '\x5', 'H', '%', '\x2', '\x292', '\x2B0', '\a', '\x32', '\x2', '\x2',
        '\x293', '\x2B0', '\a', '\x33', '\x2', '\x2', '\x294', '\x2B0', '\a',
        '-', '\x2', '\x2', '\x295', '\x297', '\t', '\x3', '\x2', '\x2', '\x296',
        '\x295', '\x3', '\x2', '\x2', '\x2', '\x296', '\x297', '\x3', '\x2', '\x2',
        '\x2', '\x297', '\x298', '\x3', '\x2', '\x2', '\x2', '\x298', '\x2B0',
        '\x5', '\x34', '\x1B', '\x2', '\x299', '\x2B0', '\a', '\x39', '\x2', '\x2',
        '\x29A', '\x2B0', '\a', '=', '\x2', '\x2', '\x29B', '\x2B0', '\x5', 'J',
        '&', '\x2', '\x29C', '\x2B0', '\a', '*', '\x2', '\x2', '\x29D', '\x2B0',
        '\a', '\x34', '\x2', '\x2', '\x29E', '\x2B0', '\a', 'U', '\x2', '\x2',
        '\x29F', '\x2B0', '\a', '\x38', '\x2', '\x2', '\x2A0', '\x2B0', '\a',
        '>', '\x2', '\x2', '\x2A1', '\x2B0', '\a', '?', '\x2', '\x2', '\x2A2',
        '\x2B0', '\a', ':', '\x2', '\x2', '\x2A3', '\x2B0', '\a', ';', '\x2',
        '\x2', '\x2A4', '\x2B0', '\a', '<', '\x2', '\x2', '\x2A5', '\x2B0', '\a',
        'L', '\x2', '\x2', '\x2A6', '\x2B0', '\a', 'V', '\x2', '\x2', '\x2A7',
        '\x2AB', '\a', '\x44', '\x2', '\x2', '\x2A8', '\x2AA', '\x5', '\x36',
        '\x1C', '\x2', '\x2A9', '\x2A8', '\x3', '\x2', '\x2', '\x2', '\x2AA',
        '\x2AD', '\x3', '\x2', '\x2', '\x2', '\x2AB', '\x2A9', '\x3', '\x2', '\x2',
        '\x2', '\x2AB', '\x2AC', '\x3', '\x2', '\x2', '\x2', '\x2AC', '\x2AE',
        '\x3', '\x2', '\x2', '\x2', '\x2AD', '\x2AB', '\x3', '\x2', '\x2', '\x2',
        '\x2AE', '\x2B0', '\a', '\x45', '\x2', '\x2', '\x2AF', '\x282', '\x3',
        '\x2', '\x2', '\x2', '\x2AF', '\x286', '\x3', '\x2', '\x2', '\x2', '\x2AF',
        '\x28A', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x28E', '\x3', '\x2', '\x2',
        '\x2', '\x2AF', '\x291', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x292',
        '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x293', '\x3', '\x2', '\x2', '\x2',
        '\x2AF', '\x294', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x296', '\x3',
        '\x2', '\x2', '\x2', '\x2AF', '\x299', '\x3', '\x2', '\x2', '\x2', '\x2AF',
        '\x29A', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x29B', '\x3', '\x2', '\x2',
        '\x2', '\x2AF', '\x29C', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x29D',
        '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x29E', '\x3', '\x2', '\x2', '\x2',
        '\x2AF', '\x29F', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x2A0', '\x3',
        '\x2', '\x2', '\x2', '\x2AF', '\x2A1', '\x3', '\x2', '\x2', '\x2', '\x2AF',
        '\x2A2', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x2A3', '\x3', '\x2', '\x2',
        '\x2', '\x2AF', '\x2A4', '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x2A5',
        '\x3', '\x2', '\x2', '\x2', '\x2AF', '\x2A6', '\x3', '\x2', '\x2', '\x2',
        '\x2AF', '\x2A7', '\x3', '\x2', '\x2', '\x2', '\x2B0', '\x2B4', '\x3',
        '\x2', '\x2', '\x2', '\x2B1', '\x2B3', '\a', 'P', '\x2', '\x2', '\x2B2',
        '\x2B1', '\x3', '\x2', '\x2', '\x2', '\x2B3', '\x2B6', '\x3', '\x2', '\x2',
        '\x2', '\x2B4', '\x2B2', '\x3', '\x2', '\x2', '\x2', '\x2B4', '\x2B5',
        '\x3', '\x2', '\x2', '\x2', '\x2B5', '\x37', '\x3', '\x2', '\x2', '\x2',
        '\x2B6', '\x2B4', '\x3', '\x2', '\x2', '\x2', '\x2B7', '\x2B9', '\x5',
        ':', '\x1E', '\x2', '\x2B8', '\x2B7', '\x3', '\x2', '\x2', '\x2', '\x2B9',
        '\x2BA', '\x3', '\x2', '\x2', '\x2', '\x2BA', '\x2B8', '\x3', '\x2', '\x2',
        '\x2', '\x2BA', '\x2BB', '\x3', '\x2', '\x2', '\x2', '\x2BB', '\x39',
        '\x3', '\x2', '\x2', '\x2', '\x2BC', '\x2D5', '\a', ' ', '\x2', '\x2',
        '\x2BD', '\x2D5', '\a', 'K', '\x2', '\x2', '\x2BE', '\x2D5', '\a', 'J',
        '\x2', '\x2', '\x2BF', '\x2D5', '\a', 'L', '\x2', '\x2', '\x2C0', '\x2D5',
        '\a', '=', '\x2', '\x2', '\x2C1', '\x2D5', '\a', '\x44', '\x2', '\x2',
        '\x2C2', '\x2D5', '\a', '\x45', '\x2', '\x2', '\x2C3', '\x2D5', '\a',
        '/', '\x2', '\x2', '\x2C4', '\x2D5', '\a', '\x30', '\x2', '\x2', '\x2C5',
        '\x2D5', '\a', '\x31', '\x2', '\x2', '\x2C6', '\x2D5', '\a', '-', '\x2',
        '\x2', '\x2C7', '\x2D5', '\x5', 'H', '%', '\x2', '\x2C8', '\x2D5', '\x5',
        '\x34', '\x1B', '\x2', '\x2C9', '\x2D5', '\a', '\x39', '\x2', '\x2', '\x2CA',
        '\x2D5', '\a', '*', '\x2', '\x2', '\x2CB', '\x2D5', '\a', '\x34', '\x2',
        '\x2', '\x2CC', '\x2D5', '\a', 'U', '\x2', '\x2', '\x2CD', '\x2D5', '\a',
        '\x38', '\x2', '\x2', '\x2CE', '\x2D5', '\a', '>', '\x2', '\x2', '\x2CF',
        '\x2D5', '\a', '?', '\x2', '\x2', '\x2D0', '\x2D5', '\a', ':', '\x2',
        '\x2', '\x2D1', '\x2D5', '\a', ';', '\x2', '\x2', '\x2D2', '\x2D5', '\a',
        '<', '\x2', '\x2', '\x2D3', '\x2D5', '\a', 'V', '\x2', '\x2', '\x2D4',
        '\x2BC', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2BD', '\x3', '\x2', '\x2',
        '\x2', '\x2D4', '\x2BE', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2BF',
        '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2C0', '\x3', '\x2', '\x2', '\x2',
        '\x2D4', '\x2C1', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2C2', '\x3',
        '\x2', '\x2', '\x2', '\x2D4', '\x2C3', '\x3', '\x2', '\x2', '\x2', '\x2D4',
        '\x2C4', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2C5', '\x3', '\x2', '\x2',
        '\x2', '\x2D4', '\x2C6', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2C7',
        '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2C8', '\x3', '\x2', '\x2', '\x2',
        '\x2D4', '\x2C9', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2CA', '\x3',
        '\x2', '\x2', '\x2', '\x2D4', '\x2CB', '\x3', '\x2', '\x2', '\x2', '\x2D4',
        '\x2CC', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2CD', '\x3', '\x2', '\x2',
        '\x2', '\x2D4', '\x2CE', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2CF',
        '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2D0', '\x3', '\x2', '\x2', '\x2',
        '\x2D4', '\x2D1', '\x3', '\x2', '\x2', '\x2', '\x2D4', '\x2D2', '\x3',
        '\x2', '\x2', '\x2', '\x2D4', '\x2D3', '\x3', '\x2', '\x2', '\x2', '\x2D5',
        '\x2D9', '\x3', '\x2', '\x2', '\x2', '\x2D6', '\x2D8', '\a', 'P', '\x2',
        '\x2', '\x2D7', '\x2D6', '\x3', '\x2', '\x2', '\x2', '\x2D8', '\x2DB',
        '\x3', '\x2', '\x2', '\x2', '\x2D9', '\x2D7', '\x3', '\x2', '\x2', '\x2',
        '\x2D9', '\x2DA', '\x3', '\x2', '\x2', '\x2', '\x2DA', ';', '\x3', '\x2',
        '\x2', '\x2', '\x2DB', '\x2D9', '\x3', '\x2', '\x2', '\x2', '\x2DC', '\x2E2',
        '\x5', '@', '!', '\x2', '\x2DD', '\x2DE', '\x5', '>', ' ', '\x2', '\x2DE',
        '\x2DF', '\x5', '@', '!', '\x2', '\x2DF', '\x2E1', '\x3', '\x2', '\x2',
        '\x2', '\x2E0', '\x2DD', '\x3', '\x2', '\x2', '\x2', '\x2E1', '\x2E4',
        '\x3', '\x2', '\x2', '\x2', '\x2E2', '\x2E0', '\x3', '\x2', '\x2', '\x2',
        '\x2E2', '\x2E3', '\x3', '\x2', '\x2', '\x2', '\x2E3', '=', '\x3', '\x2',
        '\x2', '\x2', '\x2E4', '\x2E2', '\x3', '\x2', '\x2', '\x2', '\x2E5', '\x2E9',
        '\a', '>', '\x2', '\x2', '\x2E6', '\x2E8', '\a', 'P', '\x2', '\x2', '\x2E7',
        '\x2E6', '\x3', '\x2', '\x2', '\x2', '\x2E8', '\x2EB', '\x3', '\x2', '\x2',
        '\x2', '\x2E9', '\x2E7', '\x3', '\x2', '\x2', '\x2', '\x2E9', '\x2EA',
        '\x3', '\x2', '\x2', '\x2', '\x2EA', '\x2FC', '\x3', '\x2', '\x2', '\x2',
        '\x2EB', '\x2E9', '\x3', '\x2', '\x2', '\x2', '\x2EC', '\x2F0', '\a',
        'K', '\x2', '\x2', '\x2ED', '\x2EF', '\a', 'P', '\x2', '\x2', '\x2EE',
        '\x2ED', '\x3', '\x2', '\x2', '\x2', '\x2EF', '\x2F2', '\x3', '\x2', '\x2',
        '\x2', '\x2F0', '\x2EE', '\x3', '\x2', '\x2', '\x2', '\x2F0', '\x2F1',
        '\x3', '\x2', '\x2', '\x2', '\x2F1', '\x2FC', '\x3', '\x2', '\x2', '\x2',
        '\x2F2', '\x2F0', '\x3', '\x2', '\x2', '\x2', '\x2F3', '\x2F7', '\a',
        'I', '\x2', '\x2', '\x2F4', '\x2F6', '\a', 'P', '\x2', '\x2', '\x2F5',
        '\x2F4', '\x3', '\x2', '\x2', '\x2', '\x2F6', '\x2F9', '\x3', '\x2', '\x2',
        '\x2', '\x2F7', '\x2F5', '\x3', '\x2', '\x2', '\x2', '\x2F7', '\x2F8',
        '\x3', '\x2', '\x2', '\x2', '\x2F8', '\x2FC', '\x3', '\x2', '\x2', '\x2',
        '\x2F9', '\x2F7', '\x3', '\x2', '\x2', '\x2', '\x2FA', '\x2FC', '\a',
        'P', '\x2', '\x2', '\x2FB', '\x2E5', '\x3', '\x2', '\x2', '\x2', '\x2FB',
        '\x2EC', '\x3', '\x2', '\x2', '\x2', '\x2FB', '\x2F3', '\x3', '\x2', '\x2',
        '\x2', '\x2FB', '\x2FA', '\x3', '\x2', '\x2', '\x2', '\x2FC', '?', '\x3',
        '\x2', '\x2', '\x2', '\x2FD', '\x301', '\t', '\x4', '\x2', '\x2', '\x2FE',
        '\x300', '\x5', '\x42', '\"', '\x2', '\x2FF', '\x2FE', '\x3', '\x2', '\x2',
        '\x2', '\x300', '\x303', '\x3', '\x2', '\x2', '\x2', '\x301', '\x2FF',
        '\x3', '\x2', '\x2', '\x2', '\x301', '\x302', '\x3', '\x2', '\x2', '\x2',
        '\x302', '\x307', '\x3', '\x2', '\x2', '\x2', '\x303', '\x301', '\x3',
        '\x2', '\x2', '\x2', '\x304', '\x306', '\a', 'P', '\x2', '\x2', '\x305',
        '\x304', '\x3', '\x2', '\x2', '\x2', '\x306', '\x309', '\x3', '\x2', '\x2',
        '\x2', '\x307', '\x305', '\x3', '\x2', '\x2', '\x2', '\x307', '\x308',
        '\x3', '\x2', '\x2', '\x2', '\x308', '\x316', '\x3', '\x2', '\x2', '\x2',
        '\x309', '\x307', '\x3', '\x2', '\x2', '\x2', '\x30A', '\x30C', '\x5',
        '\x42', '\"', '\x2', '\x30B', '\x30A', '\x3', '\x2', '\x2', '\x2', '\x30C',
        '\x30D', '\x3', '\x2', '\x2', '\x2', '\x30D', '\x30B', '\x3', '\x2', '\x2',
        '\x2', '\x30D', '\x30E', '\x3', '\x2', '\x2', '\x2', '\x30E', '\x312',
        '\x3', '\x2', '\x2', '\x2', '\x30F', '\x311', '\a', 'P', '\x2', '\x2',
        '\x310', '\x30F', '\x3', '\x2', '\x2', '\x2', '\x311', '\x314', '\x3',
        '\x2', '\x2', '\x2', '\x312', '\x310', '\x3', '\x2', '\x2', '\x2', '\x312',
        '\x313', '\x3', '\x2', '\x2', '\x2', '\x313', '\x316', '\x3', '\x2', '\x2',
        '\x2', '\x314', '\x312', '\x3', '\x2', '\x2', '\x2', '\x315', '\x2FD',
        '\x3', '\x2', '\x2', '\x2', '\x315', '\x30B', '\x3', '\x2', '\x2', '\x2',
        '\x316', '\x41', '\x3', '\x2', '\x2', '\x2', '\x317', '\x326', '\a', '-',
        '\x2', '\x2', '\x318', '\x326', '\a', '*', '\x2', '\x2', '\x319', '\x31D',
        '\a', '\x46', '\x2', '\x2', '\x31A', '\x31C', '\a', 'P', '\x2', '\x2',
        '\x31B', '\x31A', '\x3', '\x2', '\x2', '\x2', '\x31C', '\x31F', '\x3',
        '\x2', '\x2', '\x2', '\x31D', '\x31B', '\x3', '\x2', '\x2', '\x2', '\x31D',
        '\x31E', '\x3', '\x2', '\x2', '\x2', '\x31E', '\x320', '\x3', '\x2', '\x2',
        '\x2', '\x31F', '\x31D', '\x3', '\x2', '\x2', '\x2', '\x320', '\x321',
        '\x5', '\x44', '#', '\x2', '\x321', '\x322', '\a', 'G', '\x2', '\x2',
        '\x322', '\x326', '\x3', '\x2', '\x2', '\x2', '\x323', '\x326', '\x5',
        '\x46', '$', '\x2', '\x324', '\x326', '\a', '\x19', '\x2', '\x2', '\x325',
        '\x317', '\x3', '\x2', '\x2', '\x2', '\x325', '\x318', '\x3', '\x2', '\x2',
        '\x2', '\x325', '\x319', '\x3', '\x2', '\x2', '\x2', '\x325', '\x323',
        '\x3', '\x2', '\x2', '\x2', '\x325', '\x324', '\x3', '\x2', '\x2', '\x2',
        '\x326', '\x43', '\x3', '\x2', '\x2', '\x2', '\x327', '\x32B', '\a', ' ',
        '\x2', '\x2', '\x328', '\x32A', '\a', 'P', '\x2', '\x2', '\x329', '\x328',
        '\x3', '\x2', '\x2', '\x2', '\x32A', '\x32D', '\x3', '\x2', '\x2', '\x2',
        '\x32B', '\x329', '\x3', '\x2', '\x2', '\x2', '\x32B', '\x32C', '\x3',
        '\x2', '\x2', '\x2', '\x32C', '\x33F', '\x3', '\x2', '\x2', '\x2', '\x32D',
        '\x32B', '\x3', '\x2', '\x2', '\x2', '\x32E', '\x332', '\t', '\x5', '\x2',
        '\x2', '\x32F', '\x331', '\a', 'P', '\x2', '\x2', '\x330', '\x32F', '\x3',
        '\x2', '\x2', '\x2', '\x331', '\x334', '\x3', '\x2', '\x2', '\x2', '\x332',
        '\x330', '\x3', '\x2', '\x2', '\x2', '\x332', '\x333', '\x3', '\x2', '\x2',
        '\x2', '\x333', '\x337', '\x3', '\x2', '\x2', '\x2', '\x334', '\x332',
        '\x3', '\x2', '\x2', '\x2', '\x335', '\x338', '\a', ' ', '\x2', '\x2',
        '\x336', '\x338', '\x5', 'H', '%', '\x2', '\x337', '\x335', '\x3', '\x2',
        '\x2', '\x2', '\x337', '\x336', '\x3', '\x2', '\x2', '\x2', '\x338', '\x33C',
        '\x3', '\x2', '\x2', '\x2', '\x339', '\x33B', '\a', 'P', '\x2', '\x2',
        '\x33A', '\x339', '\x3', '\x2', '\x2', '\x2', '\x33B', '\x33E', '\x3',
        '\x2', '\x2', '\x2', '\x33C', '\x33A', '\x3', '\x2', '\x2', '\x2', '\x33C',
        '\x33D', '\x3', '\x2', '\x2', '\x2', '\x33D', '\x340', '\x3', '\x2', '\x2',
        '\x2', '\x33E', '\x33C', '\x3', '\x2', '\x2', '\x2', '\x33F', '\x32E',
        '\x3', '\x2', '\x2', '\x2', '\x33F', '\x340', '\x3', '\x2', '\x2', '\x2',
        '\x340', '\x45', '\x3', '\x2', '\x2', '\x2', '\x341', '\x343', '\a', '\x38',
        '\x2', '\x2', '\x342', '\x344', '\a', '\x38', '\x2', '\x2', '\x343', '\x342',
        '\x3', '\x2', '\x2', '\x2', '\x343', '\x344', '\x3', '\x2', '\x2', '\x2',
        '\x344', '\x366', '\x3', '\x2', '\x2', '\x2', '\x345', '\x347', '\a',
        'J', '\x2', '\x2', '\x346', '\x345', '\x3', '\x2', '\x2', '\x2', '\x346',
        '\x347', '\x3', '\x2', '\x2', '\x2', '\x347', '\x348', '\x3', '\x2', '\x2',
        '\x2', '\x348', '\x367', '\a', ' ', '\x2', '\x2', '\x349', '\x34D', '\a',
        'T', '\x2', '\x2', '\x34A', '\x34C', '\a', 'P', '\x2', '\x2', '\x34B',
        '\x34A', '\x3', '\x2', '\x2', '\x2', '\x34C', '\x34F', '\x3', '\x2', '\x2',
        '\x2', '\x34D', '\x34B', '\x3', '\x2', '\x2', '\x2', '\x34D', '\x34E',
        '\x3', '\x2', '\x2', '\x2', '\x34E', '\x35D', '\x3', '\x2', '\x2', '\x2',
        '\x34F', '\x34D', '\x3', '\x2', '\x2', '\x2', '\x350', '\x352', '\a',
        'J', '\x2', '\x2', '\x351', '\x350', '\x3', '\x2', '\x2', '\x2', '\x351',
        '\x352', '\x3', '\x2', '\x2', '\x2', '\x352', '\x353', '\x3', '\x2', '\x2',
        '\x2', '\x353', '\x35E', '\a', ' ', '\x2', '\x2', '\x354', '\x356', '\a',
        'J', '\x2', '\x2', '\x355', '\x354', '\x3', '\x2', '\x2', '\x2', '\x355',
        '\x356', '\x3', '\x2', '\x2', '\x2', '\x356', '\x357', '\x3', '\x2', '\x2',
        '\x2', '\x357', '\x35E', '\a', '/', '\x2', '\x2', '\x358', '\x35A', '\a',
        'J', '\x2', '\x2', '\x359', '\x358', '\x3', '\x2', '\x2', '\x2', '\x359',
        '\x35A', '\x3', '\x2', '\x2', '\x2', '\x35A', '\x35B', '\x3', '\x2', '\x2',
        '\x2', '\x35B', '\x35E', '\a', '.', '\x2', '\x2', '\x35C', '\x35E', '\x5',
        '@', '!', '\x2', '\x35D', '\x351', '\x3', '\x2', '\x2', '\x2', '\x35D',
        '\x355', '\x3', '\x2', '\x2', '\x2', '\x35D', '\x359', '\x3', '\x2', '\x2',
        '\x2', '\x35D', '\x35C', '\x3', '\x2', '\x2', '\x2', '\x35E', '\x362',
        '\x3', '\x2', '\x2', '\x2', '\x35F', '\x361', '\a', 'P', '\x2', '\x2',
        '\x360', '\x35F', '\x3', '\x2', '\x2', '\x2', '\x361', '\x364', '\x3',
        '\x2', '\x2', '\x2', '\x362', '\x360', '\x3', '\x2', '\x2', '\x2', '\x362',
        '\x363', '\x3', '\x2', '\x2', '\x2', '\x363', '\x365', '\x3', '\x2', '\x2',
        '\x2', '\x364', '\x362', '\x3', '\x2', '\x2', '\x2', '\x365', '\x367',
        '\a', '\x45', '\x2', '\x2', '\x366', '\x346', '\x3', '\x2', '\x2', '\x2',
        '\x366', '\x349', '\x3', '\x2', '\x2', '\x2', '\x367', 'G', '\x3', '\x2',
        '\x2', '\x2', '\x368', '\x369', '\t', '\x6', '\x2', '\x2', '\x369', 'I',
        '\x3', '\x2', '\x2', '\x2', '\x36A', '\x36E', '\a', '\x46', '\x2', '\x2',
        '\x36B', '\x36D', '\a', 'P', '\x2', '\x2', '\x36C', '\x36B', '\x3', '\x2',
        '\x2', '\x2', '\x36D', '\x370', '\x3', '\x2', '\x2', '\x2', '\x36E', '\x36C',
        '\x3', '\x2', '\x2', '\x2', '\x36E', '\x36F', '\x3', '\x2', '\x2', '\x2',
        '\x36F', '\x374', '\x3', '\x2', '\x2', '\x2', '\x370', '\x36E', '\x3',
        '\x2', '\x2', '\x2', '\x371', '\x373', '\x5', 'L', '\'', '\x2', '\x372',
        '\x371', '\x3', '\x2', '\x2', '\x2', '\x373', '\x376', '\x3', '\x2', '\x2',
        '\x2', '\x374', '\x372', '\x3', '\x2', '\x2', '\x2', '\x374', '\x375',
        '\x3', '\x2', '\x2', '\x2', '\x375', '\x377', '\x3', '\x2', '\x2', '\x2',
        '\x376', '\x374', '\x3', '\x2', '\x2', '\x2', '\x377', '\x37A', '\a',
        'G', '\x2', '\x2', '\x378', '\x37A', '\a', '\x1B', '\x2', '\x2', '\x379',
        '\x36A', '\x3', '\x2', '\x2', '\x2', '\x379', '\x378', '\x3', '\x2', '\x2',
        '\x2', '\x37A', 'K', '\x3', '\x2', '\x2', '\x2', '\x37B', '\x37D', '\a',
        'J', '\x2', '\x2', '\x37C', '\x37B', '\x3', '\x2', '\x2', '\x2', '\x37C',
        '\x37D', '\x3', '\x2', '\x2', '\x2', '\x37D', '\x37E', '\x3', '\x2', '\x2',
        '\x2', '\x37E', '\x382', '\a', ' ', '\x2', '\x2', '\x37F', '\x381', '\a',
        'P', '\x2', '\x2', '\x380', '\x37F', '\x3', '\x2', '\x2', '\x2', '\x381',
        '\x384', '\x3', '\x2', '\x2', '\x2', '\x382', '\x380', '\x3', '\x2', '\x2',
        '\x2', '\x382', '\x383', '\x3', '\x2', '\x2', '\x2', '\x383', '\x387',
        '\x3', '\x2', '\x2', '\x2', '\x384', '\x382', '\x3', '\x2', '\x2', '\x2',
        '\x385', '\x387', '\a', '\x1B', '\x2', '\x2', '\x386', '\x37C', '\x3',
        '\x2', '\x2', '\x2', '\x386', '\x385', '\x3', '\x2', '\x2', '\x2', '\x387',
        'M', '\x3', '\x2', '\x2', '\x2', '\x388', '\x3BF', '\a', ' ', '\x2', '\x2',
        '\x389', '\x3BF', '\a', '*', '\x2', '\x2', '\x38A', '\x3BF', '\a', '/',
        '\x2', '\x2', '\x38B', '\x3BF', '\a', '\x30', '\x2', '\x2', '\x38C', '\x3BF',
        '\a', '\x31', '\x2', '\x2', '\x38D', '\x3BF', '\x5', 'H', '%', '\x2',
        '\x38E', '\x3BF', '\a', '\x32', '\x2', '\x2', '\x38F', '\x3BF', '\a',
        '\x33', '\x2', '\x2', '\x390', '\x3BF', '\a', '-', '\x2', '\x2', '\x391',
        '\x3BF', '\a', '\x34', '\x2', '\x2', '\x392', '\x3BF', '\a', 'U', '\x2',
        '\x2', '\x393', '\x3BF', '\a', '\x38', '\x2', '\x2', '\x394', '\x3BF',
        '\a', '\x39', '\x2', '\x2', '\x395', '\x3BF', '\a', '>', '\x2', '\x2',
        '\x396', '\x3BF', '\a', '?', '\x2', '\x2', '\x397', '\x3BF', '\a', ':',
        '\x2', '\x2', '\x398', '\x3BF', '\a', ';', '\x2', '\x2', '\x399', '\x3BF',
        '\a', '<', '\x2', '\x2', '\x39A', '\x3BF', '\a', '=', '\x2', '\x2', '\x39B',
        '\x3BF', '\a', 'H', '\x2', '\x2', '\x39C', '\x3BF', '\a', 'J', '\x2',
        '\x2', '\x39D', '\x3BF', '\a', 'K', '\x2', '\x2', '\x39E', '\x3BF', '\a',
        'L', '\x2', '\x2', '\x39F', '\x3A3', '\a', 'T', '\x2', '\x2', '\x3A0',
        '\x3A2', '\a', 'P', '\x2', '\x2', '\x3A1', '\x3A0', '\x3', '\x2', '\x2',
        '\x2', '\x3A2', '\x3A5', '\x3', '\x2', '\x2', '\x2', '\x3A3', '\x3A1',
        '\x3', '\x2', '\x2', '\x2', '\x3A3', '\x3A4', '\x3', '\x2', '\x2', '\x2',
        '\x3A4', '\x3A9', '\x3', '\x2', '\x2', '\x2', '\x3A5', '\x3A3', '\x3',
        '\x2', '\x2', '\x2', '\x3A6', '\x3A8', '\x5', 'N', '(', '\x2', '\x3A7',
        '\x3A6', '\x3', '\x2', '\x2', '\x2', '\x3A8', '\x3AB', '\x3', '\x2', '\x2',
        '\x2', '\x3A9', '\x3A7', '\x3', '\x2', '\x2', '\x2', '\x3A9', '\x3AA',
        '\x3', '\x2', '\x2', '\x2', '\x3AA', '\x3AC', '\x3', '\x2', '\x2', '\x2',
        '\x3AB', '\x3A9', '\x3', '\x2', '\x2', '\x2', '\x3AC', '\x3BF', '\a',
        '\x45', '\x2', '\x2', '\x3AD', '\x3BF', '\a', 'V', '\x2', '\x2', '\x3AE',
        '\x3B2', '\a', '\x44', '\x2', '\x2', '\x3AF', '\x3B1', '\x5', 'N', '(',
        '\x2', '\x3B0', '\x3AF', '\x3', '\x2', '\x2', '\x2', '\x3B1', '\x3B4',
        '\x3', '\x2', '\x2', '\x2', '\x3B2', '\x3B0', '\x3', '\x2', '\x2', '\x2',
        '\x3B2', '\x3B3', '\x3', '\x2', '\x2', '\x2', '\x3B3', '\x3B5', '\x3',
        '\x2', '\x2', '\x2', '\x3B4', '\x3B2', '\x3', '\x2', '\x2', '\x2', '\x3B5',
        '\x3BF', '\a', '\x45', '\x2', '\x2', '\x3B6', '\x3BA', '\a', '\x46', '\x2',
        '\x2', '\x3B7', '\x3B9', '\x5', 'N', '(', '\x2', '\x3B8', '\x3B7', '\x3',
        '\x2', '\x2', '\x2', '\x3B9', '\x3BC', '\x3', '\x2', '\x2', '\x2', '\x3BA',
        '\x3B8', '\x3', '\x2', '\x2', '\x2', '\x3BA', '\x3BB', '\x3', '\x2', '\x2',
        '\x2', '\x3BB', '\x3BD', '\x3', '\x2', '\x2', '\x2', '\x3BC', '\x3BA',
        '\x3', '\x2', '\x2', '\x2', '\x3BD', '\x3BF', '\a', 'G', '\x2', '\x2',
        '\x3BE', '\x388', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x389', '\x3',
        '\x2', '\x2', '\x2', '\x3BE', '\x38A', '\x3', '\x2', '\x2', '\x2', '\x3BE',
        '\x38B', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x38C', '\x3', '\x2', '\x2',
        '\x2', '\x3BE', '\x38D', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x38E',
        '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x38F', '\x3', '\x2', '\x2', '\x2',
        '\x3BE', '\x390', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x391', '\x3',
        '\x2', '\x2', '\x2', '\x3BE', '\x392', '\x3', '\x2', '\x2', '\x2', '\x3BE',
        '\x393', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x394', '\x3', '\x2', '\x2',
        '\x2', '\x3BE', '\x395', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x396',
        '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x397', '\x3', '\x2', '\x2', '\x2',
        '\x3BE', '\x398', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x399', '\x3',
        '\x2', '\x2', '\x2', '\x3BE', '\x39A', '\x3', '\x2', '\x2', '\x2', '\x3BE',
        '\x39B', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x39C', '\x3', '\x2', '\x2',
        '\x2', '\x3BE', '\x39D', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x39E',
        '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x39F', '\x3', '\x2', '\x2', '\x2',
        '\x3BE', '\x3AD', '\x3', '\x2', '\x2', '\x2', '\x3BE', '\x3AE', '\x3',
        '\x2', '\x2', '\x2', '\x3BE', '\x3B6', '\x3', '\x2', '\x2', '\x2', '\x3BF',
        '\x3C3', '\x3', '\x2', '\x2', '\x2', '\x3C0', '\x3C2', '\a', 'P', '\x2',
        '\x2', '\x3C1', '\x3C0', '\x3', '\x2', '\x2', '\x2', '\x3C2', '\x3C5',
        '\x3', '\x2', '\x2', '\x2', '\x3C3', '\x3C1', '\x3', '\x2', '\x2', '\x2',
        '\x3C3', '\x3C4', '\x3', '\x2', '\x2', '\x2', '\x3C4', 'O', '\x3', '\x2',
        '\x2', '\x2', '\x3C5', '\x3C3', '\x3', '\x2', '\x2', '\x2', '\x3C6', '\x3C7',
        '\t', '\a', '\x2', '\x2', '\x3C7', 'Q', '\x3', '\x2', '\x2', '\x2', '\x3C8',
        '\x3E1', '\a', '*', '\x2', '\x2', '\x3C9', '\x3E1', '\a', '/', '\x2',
        '\x2', '\x3CA', '\x3E1', '\a', '\x30', '\x2', '\x2', '\x3CB', '\x3E1',
        '\a', '\x31', '\x2', '\x2', '\x3CC', '\x3E1', '\x5', 'H', '%', '\x2',
        '\x3CD', '\x3E1', '\a', '\x39', '\x2', '\x2', '\x3CE', '\x3E1', '\a',
        '-', '\x2', '\x2', '\x3CF', '\x3E1', '\a', '\x32', '\x2', '\x2', '\x3D0',
        '\x3E1', '\a', '\x33', '\x2', '\x2', '\x3D1', '\x3E1', '\a', '>', '\x2',
        '\x2', '\x3D2', '\x3E1', '\a', '?', '\x2', '\x2', '\x3D3', '\x3E1', '\a',
        ':', '\x2', '\x2', '\x3D4', '\x3E1', '\a', ';', '\x2', '\x2', '\x3D5',
        '\x3E1', '\a', '<', '\x2', '\x2', '\x3D6', '\x3E1', '\a', '=', '\x2',
        '\x2', '\x3D7', '\x3E1', '\a', 'H', '\x2', '\x2', '\x3D8', '\x3E1', '\a',
        'K', '\x2', '\x2', '\x3D9', '\x3E1', '\a', 'L', '\x2', '\x2', '\x3DA',
        '\x3E1', '\a', 'V', '\x2', '\x2', '\x3DB', '\x3E1', '\a', 'U', '\x2',
        '\x2', '\x3DC', '\x3E1', '\a', '\x38', '\x2', '\x2', '\x3DD', '\x3E1',
        '\a', '^', '\x2', '\x2', '\x3DE', '\x3E1', '\a', 'Z', '\x2', '\x2', '\x3DF',
        '\x3E1', '\a', '[', '\x2', '\x2', '\x3E0', '\x3C8', '\x3', '\x2', '\x2',
        '\x2', '\x3E0', '\x3C9', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3CA',
        '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3CB', '\x3', '\x2', '\x2', '\x2',
        '\x3E0', '\x3CC', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3CD', '\x3',
        '\x2', '\x2', '\x2', '\x3E0', '\x3CE', '\x3', '\x2', '\x2', '\x2', '\x3E0',
        '\x3CF', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3D0', '\x3', '\x2', '\x2',
        '\x2', '\x3E0', '\x3D1', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3D2',
        '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3D3', '\x3', '\x2', '\x2', '\x2',
        '\x3E0', '\x3D4', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3D5', '\x3',
        '\x2', '\x2', '\x2', '\x3E0', '\x3D6', '\x3', '\x2', '\x2', '\x2', '\x3E0',
        '\x3D7', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3D8', '\x3', '\x2', '\x2',
        '\x2', '\x3E0', '\x3D9', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3DA',
        '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3DB', '\x3', '\x2', '\x2', '\x2',
        '\x3E0', '\x3DC', '\x3', '\x2', '\x2', '\x2', '\x3E0', '\x3DD', '\x3',
        '\x2', '\x2', '\x2', '\x3E0', '\x3DE', '\x3', '\x2', '\x2', '\x2', '\x3E0',
        '\x3DF', '\x3', '\x2', '\x2', '\x2', '\x3E1', '\x3E5', '\x3', '\x2', '\x2',
        '\x2', '\x3E2', '\x3E4', '\a', 'P', '\x2', '\x2', '\x3E3', '\x3E2', '\x3',
        '\x2', '\x2', '\x2', '\x3E4', '\x3E7', '\x3', '\x2', '\x2', '\x2', '\x3E5',
        '\x3E3', '\x3', '\x2', '\x2', '\x2', '\x3E5', '\x3E6', '\x3', '\x2', '\x2',
        '\x2', '\x3E6', 'S', '\x3', '\x2', '\x2', '\x2', '\x3E7', '\x3E5', '\x3',
        '\x2', '\x2', '\x2', '\x3E8', '\x402', '\a', '/', '\x2', '\x2', '\x3E9',
        '\x402', '\a', '\x30', '\x2', '\x2', '\x3EA', '\x402', '\a', '\x31', '\x2',
        '\x2', '\x3EB', '\x402', '\x5', 'H', '%', '\x2', '\x3EC', '\x402', '\a',
        '\x32', '\x2', '\x2', '\x3ED', '\x402', '\a', '\x33', '\x2', '\x2', '\x3EE',
        '\x402', '\a', '\x34', '\x2', '\x2', '\x3EF', '\x402', '\a', 'U', '\x2',
        '\x2', '\x3F0', '\x402', '\a', '\x39', '\x2', '\x2', '\x3F1', '\x402',
        '\a', '>', '\x2', '\x2', '\x3F2', '\x402', '\a', '?', '\x2', '\x2', '\x3F3',
        '\x402', '\a', ':', '\x2', '\x2', '\x3F4', '\x402', '\a', ';', '\x2',
        '\x2', '\x3F5', '\x402', '\a', '<', '\x2', '\x2', '\x3F6', '\x402', '\a',
        '=', '\x2', '\x2', '\x3F7', '\x402', '\a', 'H', '\x2', '\x2', '\x3F8',
        '\x402', '\a', 'J', '\x2', '\x2', '\x3F9', '\x402', '\a', 'K', '\x2',
        '\x2', '\x3FA', '\x402', '\a', 'V', '\x2', '\x2', '\x3FB', '\x402', '\a',
        '\x45', '\x2', '\x2', '\x3FC', '\x402', '\a', 'Z', '\x2', '\x2', '\x3FD',
        '\x402', '\a', 'M', '\x2', '\x2', '\x3FE', '\x402', '\a', 'O', '\x2',
        '\x2', '\x3FF', '\x402', '\a', 'N', '\x2', '\x2', '\x400', '\x402', '\a',
        '[', '\x2', '\x2', '\x401', '\x3E8', '\x3', '\x2', '\x2', '\x2', '\x401',
        '\x3E9', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3EA', '\x3', '\x2', '\x2',
        '\x2', '\x401', '\x3EB', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3EC',
        '\x3', '\x2', '\x2', '\x2', '\x401', '\x3ED', '\x3', '\x2', '\x2', '\x2',
        '\x401', '\x3EE', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3EF', '\x3',
        '\x2', '\x2', '\x2', '\x401', '\x3F0', '\x3', '\x2', '\x2', '\x2', '\x401',
        '\x3F1', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3F2', '\x3', '\x2', '\x2',
        '\x2', '\x401', '\x3F3', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3F4',
        '\x3', '\x2', '\x2', '\x2', '\x401', '\x3F5', '\x3', '\x2', '\x2', '\x2',
        '\x401', '\x3F6', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3F7', '\x3',
        '\x2', '\x2', '\x2', '\x401', '\x3F8', '\x3', '\x2', '\x2', '\x2', '\x401',
        '\x3F9', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3FA', '\x3', '\x2', '\x2',
        '\x2', '\x401', '\x3FB', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3FC',
        '\x3', '\x2', '\x2', '\x2', '\x401', '\x3FD', '\x3', '\x2', '\x2', '\x2',
        '\x401', '\x3FE', '\x3', '\x2', '\x2', '\x2', '\x401', '\x3FF', '\x3',
        '\x2', '\x2', '\x2', '\x401', '\x400', '\x3', '\x2', '\x2', '\x2', '\x402',
        'U', '\x3', '\x2', '\x2', '\x2', '\x403', '\x41E', '\a', '/', '\x2', '\x2',
        '\x404', '\x41E', '\a', '\x30', '\x2', '\x2', '\x405', '\x41E', '\a',
        '\x31', '\x2', '\x2', '\x406', '\x41E', '\x5', 'H', '%', '\x2', '\x407',
        '\x41E', '\a', '\x32', '\x2', '\x2', '\x408', '\x41E', '\a', '\x33', '\x2',
        '\x2', '\x409', '\x41E', '\a', '\x34', '\x2', '\x2', '\x40A', '\x41E',
        '\a', 'U', '\x2', '\x2', '\x40B', '\x41E', '\a', '>', '\x2', '\x2', '\x40C',
        '\x41E', '\a', '?', '\x2', '\x2', '\x40D', '\x41E', '\a', ':', '\x2',
        '\x2', '\x40E', '\x41E', '\a', ';', '\x2', '\x2', '\x40F', '\x41E', '\a',
        '<', '\x2', '\x2', '\x410', '\x41E', '\a', '=', '\x2', '\x2', '\x411',
        '\x41E', '\a', 'H', '\x2', '\x2', '\x412', '\x41E', '\a', 'J', '\x2',
        '\x2', '\x413', '\x41E', '\a', 'K', '\x2', '\x2', '\x414', '\x41E', '\a',
        'V', '\x2', '\x2', '\x415', '\x41E', '\a', '\x45', '\x2', '\x2', '\x416',
        '\x41E', '\a', 'Z', '\x2', '\x2', '\x417', '\x41E', '\a', '\x38', '\x2',
        '\x2', '\x418', '\x41E', '\a', 'L', '\x2', '\x2', '\x419', '\x41E', '\a',
        'T', '\x2', '\x2', '\x41A', '\x41E', '\a', 'M', '\x2', '\x2', '\x41B',
        '\x41E', '\a', 'O', '\x2', '\x2', '\x41C', '\x41E', '\a', 'N', '\x2',
        '\x2', '\x41D', '\x403', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x404',
        '\x3', '\x2', '\x2', '\x2', '\x41D', '\x405', '\x3', '\x2', '\x2', '\x2',
        '\x41D', '\x406', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x407', '\x3',
        '\x2', '\x2', '\x2', '\x41D', '\x408', '\x3', '\x2', '\x2', '\x2', '\x41D',
        '\x409', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x40A', '\x3', '\x2', '\x2',
        '\x2', '\x41D', '\x40B', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x40C',
        '\x3', '\x2', '\x2', '\x2', '\x41D', '\x40D', '\x3', '\x2', '\x2', '\x2',
        '\x41D', '\x40E', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x40F', '\x3',
        '\x2', '\x2', '\x2', '\x41D', '\x410', '\x3', '\x2', '\x2', '\x2', '\x41D',
        '\x411', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x412', '\x3', '\x2', '\x2',
        '\x2', '\x41D', '\x413', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x414',
        '\x3', '\x2', '\x2', '\x2', '\x41D', '\x415', '\x3', '\x2', '\x2', '\x2',
        '\x41D', '\x416', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x417', '\x3',
        '\x2', '\x2', '\x2', '\x41D', '\x418', '\x3', '\x2', '\x2', '\x2', '\x41D',
        '\x419', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x41A', '\x3', '\x2', '\x2',
        '\x2', '\x41D', '\x41B', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x41C',
        '\x3', '\x2', '\x2', '\x2', '\x41E', 'W', '\x3', '\x2', '\x2', '\x2',
        '\x95', '[', '\x62', '\x64', 'k', 'm', 'r', 'y', '\x80', '\x84', '\x8D',
        '\x94', '\x9E', '\xA5', '\xAF', '\xB3', '\xB9', '\xC0', '\xC5', '\xCD',
        '\xD4', '\xDB', '\xE2', '\xE7', '\xED', '\xF5', '\xF9', '\xFC', '\x101',
        '\x108', '\x10F', '\x118', '\x11F', '\x127', '\x12E', '\x135', '\x13C',
        '\x141', '\x144', '\x14F', '\x155', '\x15C', '\x161', '\x165', '\x168',
        '\x16E', '\x175', '\x17C', '\x180', '\x186', '\x18A', '\x191', '\x197',
        '\x19E', '\x1A8', '\x1AF', '\x1B2', '\x1B8', '\x1BE', '\x1C6', '\x1CC',
        '\x1D0', '\x1D6', '\x1E0', '\x1E6', '\x1E9', '\x1EF', '\x1F8', '\x1FB',
        '\x201', '\x205', '\x209', '\x211', '\x215', '\x218', '\x21E', '\x221',
        '\x227', '\x22E', '\x232', '\x238', '\x23E', '\x245', '\x24D', '\x250',
        '\x252', '\x25A', '\x25D', '\x263', '\x26B', '\x26E', '\x270', '\x278',
        '\x27C', '\x27F', '\x282', '\x286', '\x28A', '\x28E', '\x296', '\x2AB',
        '\x2AF', '\x2B4', '\x2BA', '\x2D4', '\x2D9', '\x2E2', '\x2E9', '\x2F0',
        '\x2F7', '\x2FB', '\x301', '\x307', '\x30D', '\x312', '\x315', '\x31D',
        '\x325', '\x32B', '\x332', '\x337', '\x33C', '\x33F', '\x343', '\x346',
        '\x34D', '\x351', '\x355', '\x359', '\x35D', '\x362', '\x366', '\x36E',
        '\x374', '\x379', '\x37C', '\x382', '\x386', '\x3A3', '\x3A9', '\x3B2',
        '\x3BA', '\x3BE', '\x3C3', '\x3E0', '\x3E5', '\x401', '\x41D',
    };

    public static readonly ATN _ATN =
        new ATNDeserializer().Deserialize(_serializedATN);


}
